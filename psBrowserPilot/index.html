<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PowerShell Visual Builder</title>
    <link rel="stylesheet" href="./ui/editor.css" />
  </head>
  <body>
    <header class="app-header">
      <div class="branding">
        <div class="logo" aria-hidden="true"></div>
        <h1>PowerShell Visual Builder</h1>
      </div>
      <div class="header-actions">
        <button id="open-designer" type="button">Custom Nodes</button>
        <button id="load-flow" type="button">Load</button>
        <button id="save-flow" type="button">Save</button>
        <button id="clear-flow" type="button">Clear</button>
        <button id="export-script" class="secondary" type="button">Export Script</button>
        <button id="run-script" class="primary" type="button">Run in PowerShell</button>
      </div>
    </header>

    <div class="app-body">
      <aside class="palette-shell" aria-label="Node palette">
        <div class="palette" id="node-palette"></div>
        <div class="palette-status-bar">
          <button
            type="button"
            id="open-settings"
            class="status-icon"
            aria-haspopup="dialog"
            aria-controls="settings-dialog"
            aria-label="設定を開く"
            aria-expanded="false"
          >⚙</button>
        </div>
      </aside>
      <main class="editor" id="editor-area">
        <canvas id="connection-layer"></canvas>
        <div id="node-layer" class="node-layer" role="application" aria-label="Node editor"></div>
      </main>
    </div>

    <dialog id="property-editor">
      <form method="dialog" id="property-form">
        <header>
          <h2 id="property-title">Node Properties</h2>
        </header>
        <div class="property-fields" id="property-fields"></div>
        <menu class="property-actions">
          <button type="reset" id="property-cancel">Cancel</button>
          <button type="submit" class="primary">Save</button>
        </menu>
      </form>
    </dialog>

    <dialog id="settings-dialog" class="settings-dialog" aria-label="設定">
      <div class="settings-inner">
        <header class="settings-header">
          <h2>設定</h2>
          <button type="button" id="close-settings" class="settings-close" aria-label="設定を閉じる">
            ×
          </button>
        </header>
        <div class="settings-content">
          <div class="settings-group">
            <span id="theme-toggle-label" class="toggle-field-label">テーマ</span>
            <label class="toggle-switch" for="theme-toggle">
              <span class="toggle-text" id="theme-toggle-text">ダークモード</span>
              <input
                type="checkbox"
                id="theme-toggle"
                aria-labelledby="theme-toggle-label theme-toggle-text"
              />
              <span class="toggle-slider" aria-hidden="true"></span>
            </label>
          </div>
          <div class="settings-group stacked">
            <label for="server-url">PowerShell サーバーURL</label>
            <input
              id="server-url"
              type="text"
              inputmode="url"
              placeholder="http://127.0.0.1:8787"
            />
            <p class="settings-hint">
              <code>/runScript</code> エンドポイントを公開しているサーバーを指定してください。付属の
              <code>psBrowserPilotLocal.ps1</code> は <code>http://127.0.0.1:8787</code> で待ち受けます。
            </p>
            <div class="settings-inline-actions">
              <button type="button" id="test-server" class="small-button">接続テスト</button>
              <span id="server-status" class="settings-note">未テスト</span>
            </div>
          </div>
        </div>
      </div>
    </dialog>

    <template id="node-template">
      <div class="node" tabindex="0">
        <header class="node-header">
          <span class="node-label"></span>
          <div class="node-actions">
            <button
              class="node-open-designer"
              title="カスタムノードエディタを開く"
              type="button"
            >&lt;&gt;</button>
            <button class="node-config" title="Edit properties" type="button">⚙</button>
            <button
              class="node-delete"
              title="ノードを削除"
              type="button"
              aria-label="ノードを削除"
            >✕</button>
          </div>
        </header>
        <div class="node-ports">
          <div class="inputs"></div>
          <div class="outputs"></div>
        </div>
      </div>
    </template>

    <aside id="node-designer" class="designer" aria-hidden="true">
      <div class="designer-panel">
        <header class="designer-header">
          <div>
            <h2>カスタムノードビルダー</h2>
            <p class="designer-caption">
              ノードの入出力ポートとスクリプトを定義し、ブラウザのストレージに保存できます。
            </p>
          </div>
          <button type="button" id="close-designer" class="designer-close" aria-label="Close designer">
            ×
          </button>
        </header>
        <div class="designer-content">
          <section class="designer-sidebar">
            <div class="designer-section">
              <div class="designer-section-header">
                <h3>保存済みノード</h3>
                <button type="button" id="create-node" class="small-button">新規</button>
              </div>
              <div id="custom-node-list" class="designer-list" role="list"></div>
            </div>
            <div class="designer-section">
              <h3>サンプル</h3>
              <p class="designer-hint">サンプルを読み込むとフォームに内容がコピーされます。</p>
              <div id="sample-node-list" class="designer-list" role="list"></div>
            </div>
          </section>
          <section class="designer-form">
            <form id="custom-node-form" autocomplete="off">
              <div class="field-group">
                <label for="node-label">表示名</label>
                <input id="node-label" name="label" type="text" placeholder="例: ファイル読込" required />
              </div>
              <div class="field-grid">
                <label>
                  ノードID
                  <input id="node-id" name="id" type="text" placeholder="例: file_loader" />
                </label>
                <label>
                  カテゴリ
                  <input id="node-category" name="category" type="text" placeholder="Custom" />
                </label>
              </div>
              <div class="field-group">
                <label for="node-inputs">入力ポート（1行につき1件）</label>
                <textarea id="node-inputs" name="inputs" rows="3" placeholder="InputValue"></textarea>
              </div>
              <div class="field-group">
                <label for="node-outputs">出力ポート（1行につき1件）</label>
                <textarea id="node-outputs" name="outputs" rows="3" placeholder="Result"></textarea>
              </div>
              <div class="field-group">
                <label for="node-constants">定数入力（ Type | Key | Value ）</label>
                <textarea
                  id="node-constants"
                  name="constants"
                  rows="4"
                  placeholder="TextBox | threshold | # TODO: set value"
                ></textarea>
              </div>
              <div class="field-group">
                <label for="node-script">スクリプト</label>
                <textarea
                  id="node-script"
                  name="script"
                  class="code-area"
                  rows="12"
                  placeholder="# {{input.Value}} や {{config.threshold}} のようなプレースホルダーを使用できます。"
                ></textarea>
              </div>
              <p id="designer-status" class="designer-status" role="status" aria-live="polite"></p>
              <div class="designer-actions">
                <button type="submit" class="primary">保存</button>
                <button type="button" id="duplicate-node">複製</button>
                <button type="button" id="reset-form">リセット</button>
              </div>
            </form>
          </section>
        </div>
      </div>
    </aside>

    <script type="module">
      import {
        listCustomNodeSpecs,
        saveCustomNodeSpec,
        deleteCustomNodeSpec,
        specsToDefinitions,
        SAMPLE_NODE_TEMPLATES,
        createEmptySpec,
      } from './core/nodeLibrary.js';
      import { NodeEditor } from './core/nodeEngine.js';
      import { loadGraph, saveGraph, clearGraph } from './storage/fileStore.js';
      import { exportScript } from './export/scriptExport.js';
      import {
        runScriptWithDialog,
        loadServerUrl,
        saveServerUrl,
        normalizeServerUrl,
        DEFAULT_SERVER_URL,
      } from './export/scriptRunner.js';

      const paletteEl = document.getElementById('node-palette');
      const nodeLayer = document.getElementById('node-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const propertyDialog = document.getElementById('property-editor');
      const propertyForm = document.getElementById('property-form');
      const propertyFields = document.getElementById('property-fields');
      const nodeTemplate = document.getElementById('node-template');
      const exportButton = document.getElementById('export-script');
      const runButton = document.getElementById('run-script');
      const serverUrlInput = document.getElementById('server-url');
      const testServerBtn = document.getElementById('test-server');
      const serverStatus = document.getElementById('server-status');

      let customSpecs = listCustomNodeSpecs();
      let editor;
      let powerShellServerUrl = loadServerUrl();

      const updateServerStatus = (message, state = 'info') => {
        if (!serverStatus) return;
        const classes = ['settings-note'];
        if (state) {
          classes.push(`is-${state}`);
        }
        serverStatus.textContent = message;
        serverStatus.className = classes.join(' ');
      };

      const applyServerUrl = (value, { silent = false } = {}) => {
        const normalized = normalizeServerUrl(value);
        const next = normalized || DEFAULT_SERVER_URL;
        powerShellServerUrl = next;
        if (serverUrlInput) {
          serverUrlInput.value = next;
        }
        saveServerUrl(next);
        if (!silent) {
          updateServerStatus(`使用中: ${next}`, 'info');
        }
      };

      applyServerUrl(powerShellServerUrl, { silent: true });
      updateServerStatus(`使用中: ${powerShellServerUrl}`, 'info');

      const testServerConnection = async () => {
        const candidate = normalizeServerUrl(serverUrlInput?.value || powerShellServerUrl);
        const target = candidate || DEFAULT_SERVER_URL;
        applyServerUrl(target, { silent: true });
        updateServerStatus('接続テスト中…', 'pending');
        try {
          const response = await fetch(`${target.replace(/\/+$/, '')}/`, { method: 'GET' });
          const contentType = response.headers.get('content-type') || '';
          let data = null;
          if (contentType.includes('application/json')) {
            try {
              data = await response.json();
            } catch (error) {
              data = null;
            }
          }
          if (!response.ok) {
            throw new Error(data?.error || `HTTP ${response.status}`);
          }
          if (data?.message) {
            updateServerStatus(`接続に成功: ${data.message}`, 'success');
          } else {
            updateServerStatus('接続に成功しました。', 'success');
          }
        } catch (error) {
          updateServerStatus(`接続に失敗: ${error.message}`, 'error');
        }
      };

      serverUrlInput?.addEventListener('blur', (event) => {
        applyServerUrl(event.target.value);
      });

      serverUrlInput?.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          applyServerUrl(event.currentTarget.value);
          testServerConnection();
        }
      });

      testServerBtn?.addEventListener('click', (event) => {
        event.preventDefault();
        testServerConnection();
      });

      const showToast = (message) => {
        if (!message) return;
        const div = document.createElement('div');
        div.textContent = message;
        div.className = 'toast';
        document.body.appendChild(div);
        requestAnimationFrame(() => {
          div.classList.add('visible');
        });
        setTimeout(() => {
          div.classList.remove('visible');
          setTimeout(() => div.remove(), 240);
        }, 1800);
      };

      const refreshLibrary = ({ persist = true } = {}) => {
        customSpecs = listCustomNodeSpecs();
        if (editor) {
          editor.setLibrary(specsToDefinitions(customSpecs), { persist });
        }
        renderCustomNodeList();
      };

      const designerEl = document.getElementById('node-designer');
      const openDesignerBtn = document.getElementById('open-designer');
      const closeDesignerBtn = document.getElementById('close-designer');
      const newNodeBtn = document.getElementById('create-node');
      const customListEl = document.getElementById('custom-node-list');
      const sampleListEl = document.getElementById('sample-node-list');
      const designerForm = document.getElementById('custom-node-form');
      const resetFormBtn = document.getElementById('reset-form');
      const duplicateNodeBtn = document.getElementById('duplicate-node');
      const designerStatus = document.getElementById('designer-status');
      const scriptField = document.getElementById('node-script');
      const openSettingsBtn = document.getElementById('open-settings');
      const settingsDialog = document.getElementById('settings-dialog');
      const closeSettingsBtn = document.getElementById('close-settings');
      const themeToggle = document.getElementById('theme-toggle');

      const THEME_STORAGE_KEY = 'nodeflow.theme';
      const CONSTANT_PLACEHOLDER = '# TODO: set value';

      const fields = {
        id: document.getElementById('node-id'),
        label: document.getElementById('node-label'),
        category: document.getElementById('node-category'),
        inputs: document.getElementById('node-inputs'),
        outputs: document.getElementById('node-outputs'),
        constants: document.getElementById('node-constants'),
        script: scriptField,
      };

      let originalId = '';
      let designerInitialized = false;

      const applyTheme = (theme) => {
        const mode = theme === 'dark' ? 'dark' : 'light';
        document.body.classList.toggle('theme-dark', mode === 'dark');
        document.body.classList.toggle('theme-light', mode === 'light');
        document.documentElement.style.setProperty('color-scheme', mode);
        if (themeToggle) {
          themeToggle.checked = mode === 'dark';
        }
      };

      const detectPreferredTheme = () =>
        window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

      const loadStoredTheme = () => {
        try {
          const stored = localStorage.getItem(THEME_STORAGE_KEY);
          return stored === 'dark' || stored === 'light' ? stored : null;
        } catch (error) {
          console.warn('Failed to read theme preference', error);
          return null;
        }
      };

      const persistTheme = (theme) => {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, theme);
        } catch (error) {
          console.warn('Failed to store theme preference', error);
        }
      };

      const initializeTheme = () => {
        const stored = loadStoredTheme();
        const initial = stored || detectPreferredTheme();
        applyTheme(initial);
      };

      initializeTheme();

      themeToggle?.addEventListener('change', () => {
        const mode = themeToggle.checked ? 'dark' : 'light';
        applyTheme(mode);
        persistTheme(mode);
      });

      const openSettings = () => {
        if (!settingsDialog) return;
        if (typeof settingsDialog.showModal === 'function' && !settingsDialog.open) {
          settingsDialog.showModal();
          openSettingsBtn?.setAttribute('aria-expanded', 'true');
        }
      };

      const closeSettings = ({ returnFocus = false } = {}) => {
        if (!settingsDialog) return;
        if (settingsDialog.open) {
          settingsDialog.close();
        }
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
        if (returnFocus) {
          openSettingsBtn?.focus();
        }
      };

      openSettingsBtn?.addEventListener('click', () => {
        openSettings();
      });

      closeSettingsBtn?.addEventListener('click', () => {
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('cancel', (event) => {
        event.preventDefault();
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('close', () => {
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
      });

      const sanitizeToken = (value) =>
        String(value ?? '')
          .trim()
          .replace(/\s+/g, '_')
          .replace(/[^A-Za-z0-9_]/g, '_');

      const parsePortList = (raw) =>
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => sanitizeToken(line))
          .filter((line, index, self) => line && self.indexOf(line) === index);

      const normalizeConstantType = (value) => {
        const normalized = String(value ?? '').trim().toLowerCase();
        switch (normalized) {
          case 'checkbox':
          case 'check-box':
            return 'CheckBox';
          case 'reference':
          case 'file':
            return 'Reference';
          case 'radiobutton':
          case 'radio':
            return 'RadioButton';
          case 'text':
          case 'text-box':
          case 'textbox':
          default:
            return 'TextBox';
        }
      };

      const normalizeBooleanToken = (value) =>
        /^(true|1|yes|on)$/i.test(String(value ?? '').trim()) ? 'True' : 'False';

      const parseConstants = (raw) =>
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => {
            const parts = line.split('|').map((part) => part.trim());
            if (!parts.length) return null;
            let typeToken = 'TextBox';
            let keyToken = parts[0];
            let valueToken = CONSTANT_PLACEHOLDER;
            if (parts.length >= 3) {
              typeToken = parts[0];
              keyToken = parts[1];
              valueToken = parts.slice(2).join('|');
            } else if (parts.length === 2) {
              typeToken = 'TextBox';
              keyToken = parts[0];
              valueToken = parts[1];
            }
            const key = sanitizeToken(keyToken);
            if (!key) return null;
            const type = normalizeConstantType(typeToken);
            const rawValue = valueToken ?? CONSTANT_PLACEHOLDER;
            const value =
              type === 'CheckBox' || type === 'RadioButton'
                ? normalizeBooleanToken(rawValue)
                : rawValue || CONSTANT_PLACEHOLDER;
            return { key, type, value };
          })
          .filter((constant, index, self) =>
            constant && self.findIndex((item) => item.key === constant.key) === index
          );

      const formatConstants = (constants) =>
        (constants || [])
          .map((constant) => {
            const type = normalizeConstantType(constant?.type || 'TextBox');
            const key = sanitizeToken(constant?.key ?? '');
            if (!key) return '';
            const value =
              type === 'CheckBox' || type === 'RadioButton'
                ? normalizeBooleanToken(constant?.value ?? constant?.default)
                : constant?.value ?? constant?.default ?? CONSTANT_PLACEHOLDER;
            return `${type} | ${key} | ${value}`.trim();
          })
          .filter(Boolean)
          .join('\n');

      const cloneSpec = (spec) => {
        if (!spec) return null;
        return {
          ...spec,
          inputs: [...(spec.inputs || [])],
          outputs: [...(spec.outputs || [])],
          constants: (spec.constants || []).map((constant) => ({ ...constant })),
          script: spec.script || '',
        };
      };

      const findSpecById = (id) => customSpecs.find((spec) => spec.id === id);

      const ensureDuplicatedLabel = (label) => {
        const base = label && label.trim() ? label.trim() : 'Untitled node';
        return base.endsWith(' (複製)') ? base : `${base} (複製)`;
      };

      const generateUniqueNodeId = (seedId) => {
        const existingIds = new Set(customSpecs.map((spec) => spec.id));
        let base = sanitizeToken(seedId || '');
        if (!base) {
          base = 'custom_node';
        }
        if (!existingIds.has(base)) {
          return base;
        }
        const match = base.match(/^(.*?)(\d+)?$/);
        let prefix = match && match[1] !== undefined ? match[1] : base;
        if (!prefix) {
          prefix = base || 'custom_node';
        }
        let suffix = match && match[2] ? parseInt(match[2], 10) + 1 : 2;
        if (!Number.isFinite(suffix) || suffix < 1) {
          suffix = 2;
        }
        let candidate = `${prefix}${suffix}`;
        while (existingIds.has(candidate)) {
          suffix += 1;
          candidate = `${prefix}${suffix}`;
        }
        return candidate;
      };

      const duplicateSpecWithNewId = (spec) => {
        if (!spec) return null;
        const working = cloneSpec(spec);
        const preferredBaseId = working.id || sanitizeToken(working.label).toLowerCase();
        working.id = generateUniqueNodeId(preferredBaseId);
        working.label = ensureDuplicatedLabel(working.label);
        working.category = working.category || 'Custom';
        working.script = working.script || '';
        return saveCustomNodeSpec(working);
      };

      const duplicateCustomNodeById = (specId) => {
        const spec = findSpecById(specId);
        if (!spec) {
          return null;
        }
        const saved = duplicateSpecWithNewId(spec);
        if (saved) {
          showToast('ノードを複製しました。');
          refreshLibrary();
        }
        return saved;
      };

      const removeCustomNodeSpecs = (ids, { skipConfirm = false, silent = false } = {}) => {
        const uniqueIds = Array.isArray(ids)
          ? Array.from(new Set(ids.filter(Boolean)))
          : [];
        if (!uniqueIds.length) {
          return { removedIds: [], cancelled: false };
        }
        const specs = uniqueIds.map((id) => findSpecById(id)).filter(Boolean);
        if (!specs.length) {
          return { removedIds: [], cancelled: false };
        }
        if (!skipConfirm) {
          const message =
            specs.length === 1
              ? `${specs[0].label} を削除しますか？`
              : `${specs.length} 件のカスタムノードを削除しますか？`;
          if (!confirm(message)) {
            return { removedIds: [], cancelled: true };
          }
        }

        specs.forEach((spec) => deleteCustomNodeSpec(spec.id));
        refreshLibrary();

        if (specs.some((spec) => spec.id === originalId)) {
          if (customSpecs.length) {
            loadSpecIntoForm(customSpecs[0]);
          } else {
            loadSpecIntoForm(createEmptySpec());
          }
        }

        if (!silent) {
          showToast(
            specs.length === 1
              ? 'カスタムノードを削除しました。'
              : `${specs.length}件のカスタムノードを削除しました。`
          );
        }

        return {
          removedIds: specs.map((spec) => spec.id),
          cancelled: false,
        };
      };

      const deleteCustomNodeById = (specId, options = {}) => {
        const result = removeCustomNodeSpecs([specId], options);
        if (result.cancelled) {
          return false;
        }
        return result;
      };

      const deleteCustomNodesByIds = (ids, options = {}) => removeCustomNodeSpecs(ids, options);

      const loadSpecIntoForm = (spec, { fromSample = false } = {}) => {
        originalId = fromSample ? '' : spec.id || '';
        fields.label.value = spec.label || '';
        fields.id.value = fromSample ? '' : spec.id || '';
        fields.category.value = fromSample ? 'Custom' : spec.category || 'Custom';
        fields.inputs.value = (spec.inputs || []).join('\n');
        fields.outputs.value = (spec.outputs || []).join('\n');
        fields.constants.value = formatConstants(spec.constants || []);
        fields.script.value = spec.script || '';
        designerStatus.textContent = fromSample
          ? 'サンプルノードを読み込みました。編集して保存するとカスタムノードとして登録されます。'
          : spec.id
          ? `編集中: ${spec.id}`
          : '新しいノードを作成しています。';
      };

      const renderCustomNodeList = () => {
        customListEl.innerHTML = '';
        if (!customSpecs.length) {
          const empty = document.createElement('p');
          empty.className = 'designer-empty';
          empty.textContent = 'まだカスタムノードがありません。';
          customListEl.appendChild(empty);
          return;
        }
        customSpecs.forEach((spec) => {
          const item = document.createElement('div');
          item.className = 'designer-list-item';
          const editButton = document.createElement('button');
          editButton.type = 'button';
          editButton.className = 'designer-link';
          editButton.textContent = spec.label;
          editButton.addEventListener('click', () => loadSpecIntoForm(spec));
          const meta = document.createElement('span');
          meta.className = 'designer-meta';
          meta.textContent = spec.category || 'Custom';
          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'designer-remove';
          removeButton.textContent = '削除';
          removeButton.addEventListener('click', (event) => {
            event.stopPropagation();
            deleteCustomNodeById(spec.id);
          });
          item.append(editButton, meta, removeButton);
          customListEl.appendChild(item);
        });
      };

      const renderSampleList = () => {
        sampleListEl.innerHTML = '';
        SAMPLE_NODE_TEMPLATES.forEach((sample) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'designer-sample';
          button.innerHTML = `<strong>${sample.label}</strong><span>${sample.description}</span>`;
          button.addEventListener('click', () =>
            loadSpecIntoForm(
              {
                ...sample,
                id: '',
                label: sample.label.replace(/^Sample:\s*/i, ''),
                category: 'Custom',
                inputs: [...(sample.inputs || [])],
                outputs: [...(sample.outputs || [])],
                constants: (sample.constants || []).map((constant) => ({ ...constant })),
                script: sample.script,
              },
              { fromSample: true }
            )
          );
          sampleListEl.appendChild(button);
        });
      };

      const ensureDesignerInitialized = () => {
        if (designerInitialized) return;
        renderSampleList();
        if (customSpecs.length) {
          loadSpecIntoForm(customSpecs[0]);
        } else {
          loadSpecIntoForm(createEmptySpec());
        }
        designerInitialized = true;
      };

      const openDesigner = () => {
        ensureDesignerInitialized();
        designerEl.classList.add('open');
        designerEl.setAttribute('aria-hidden', 'false');
        document.body.classList.add('designer-open');
        renderCustomNodeList();
        setTimeout(() => fields.label.focus(), 50);
        setTimeout(() => editor?.resize(), 260);
      };

      const openDesignerForSpec = (specId, fallbackSpec) => {
        ensureDesignerInitialized();
        const findSpec = () => customSpecs.find((item) => item.id === specId);
        let spec = findSpec();

        if (!spec && fallbackSpec && fallbackSpec.id === specId) {
          spec = cloneSpec(fallbackSpec);
        }

        if (!spec) {
          refreshLibrary({ persist: false });
          spec = findSpec();
        }

        if (spec) {
          loadSpecIntoForm(spec);
          designerStatus.textContent = `編集中: ${spec.id}`;
        } else {
          loadSpecIntoForm(createEmptySpec());
          designerStatus.textContent = '指定されたカスタムノードが見つかりません。';
        }
        openDesigner();
      };

      const closeDesigner = () => {
        designerEl.classList.remove('open');
        designerEl.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('designer-open');
        setTimeout(() => editor?.resize(), 260);
      };

      editor = new NodeEditor({
        paletteEl,
        nodeLayer,
        connectionLayer,
        propertyDialog,
        propertyForm,
        propertyFields,
        nodeTemplate,
        library: specsToDefinitions(customSpecs),
        onGenerateScript: exportScript,
        onRunScript: (script) =>
          runScriptWithDialog(script, { serverUrl: powerShellServerUrl }),
        onEditCustomNode: openDesignerForSpec,
        onDuplicatePaletteNode: ({ definitionId }) => {
          const saved = duplicateCustomNodeById(definitionId);
          if (!saved) {
            return null;
          }
          const [definition] = specsToDefinitions([saved]);
          return { id: saved.id, definition };
        },
        onRemovePaletteNode: ({
          definitionId,
          definitionIds,
          skipConfirm,
          silent,
        }) => {
          if (Array.isArray(definitionIds) && definitionIds.length) {
            const result = deleteCustomNodesByIds(definitionIds, {
              skipConfirm,
              silent,
            });
            if (result.cancelled) {
              return false;
            }
            return { removedIds: result.removedIds };
          }
          return deleteCustomNodeById(definitionId, {
            skipConfirm,
            silent,
          });
        },
        persistence: {
          load: loadGraph,
          save: saveGraph,
          clear: clearGraph,
        },
      });

      window.addEventListener('resize', () => editor.resize());

      exportButton?.addEventListener('click', () => editor.exportScript());
      runButton?.addEventListener('click', () => editor.runScript());
      document.getElementById('save-flow').addEventListener('click', () => editor.persistGraph());
      document.getElementById('load-flow').addEventListener('click', () => editor.restoreGraph());
      document.getElementById('clear-flow').addEventListener('click', () => editor.clearGraph());

      openDesignerBtn.addEventListener('click', openDesigner);
      closeDesignerBtn.addEventListener('click', closeDesigner);
      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && designerEl.classList.contains('open')) {
          closeDesigner();
        }
      });

      newNodeBtn.addEventListener('click', () => {
        loadSpecIntoForm(createEmptySpec());
        designerStatus.textContent = '新しいノードを作成しています。';
      });

      duplicateNodeBtn.addEventListener('click', () => {
        const label = fields.label.value.trim();
        const spec = {
          id: sanitizeToken(fields.id.value.trim()) || originalId || sanitizeToken(label).toLowerCase(),
          label: label || 'Untitled node',
          category: fields.category.value.trim() || 'Custom',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
        };
        const saved = duplicateSpecWithNewId(spec);
        if (!saved) {
          return;
        }
        showToast('カスタムノードを複製しました。');
        refreshLibrary();
        loadSpecIntoForm(saved);
      });

      resetFormBtn.addEventListener('click', () => {
        loadSpecIntoForm(createEmptySpec());
        designerStatus.textContent = '入力をリセットしました。';
      });

      scriptField.addEventListener('keydown', (event) => {
        if (event.key === 'Tab') {
          event.preventDefault();
          const { selectionStart, selectionEnd, value } = scriptField;
          const insertion = '  ';
          scriptField.value = `${value.slice(0, selectionStart)}${insertion}${value.slice(selectionEnd)}`;
          const caret = selectionStart + insertion.length;
          scriptField.selectionStart = caret;
          scriptField.selectionEnd = caret;
        }
      });

      designerForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const label = fields.label.value.trim();
        let id = sanitizeToken(fields.id.value.trim());
        if (!id) {
          id = originalId || sanitizeToken(label).toLowerCase();
        }
        if (!id) {
          id = `custom_node_${Date.now()}`;
        }
        const spec = {
          id,
          label: label || 'Untitled node',
          category: fields.category.value.trim() || 'Custom',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
        };
        const existing = customSpecs.find((item) => item.id === spec.id);
        if (existing && existing.id !== originalId) {
          const overwrite = confirm('このIDのノードは既に存在します。上書きしますか？');
          if (!overwrite) {
            return;
          }
        }
        const saved = saveCustomNodeSpec(spec);
        showToast('カスタムノードを保存しました (ローカルストレージ)。');
        refreshLibrary();
        loadSpecIntoForm(saved);
      });

      renderCustomNodeList();

    </script>
  </body>
</html>
