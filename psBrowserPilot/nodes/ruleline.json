{
  "id": "ruleline",
  "label": "Rule Line",
  "category": "Custom",
  "execution": "ui",
  "inputs": [
    "Workbook",
    "Sheet",
    "Range"
  ],
  "outputs": [],
  "constants": [
    {
      "key": "note",
      "type": "TextBox",
      "value": "# TODO: describe behavior"
    }
  ],
  "script": "# Use {{input.Name}} to reference incoming values,\n# {{config.key}} for constant fields, and {{output.Result}} for outputs.\n# Remove these lines and write your PowerShell snippet here.",
  "ui": {
    "markup": "<div class=\"excel-ui-node borderline-node\" data-role=\"root\">\n  <div class=\"palette-header\">\n    <div class=\"palette-title\">罫線スタイル</div>\n    <div class=\"palette-status\" data-role=\"status\"></div>\n  </div>\n\n  <div class=\"palette-frame\">\n    <div class=\"border-grid\" data-role=\"grid\"></div>\n  </div>\n</div>",
    "script": "const { node, controls, updateConfig, resolveInput, ensureAutoNodes, toPowerShellLiteral } = context;\n    if (!controls) return;\n\n    const root = controls.querySelector('[data-role=\"root\"]') || controls;\n    const status = controls.querySelector('[data-role=\"status\"]');\n    const grid = controls.querySelector('[data-role=\"grid\"]');\n\n    if (!root || !status || !grid) {\n      console.warn('[ruleline] Required UI elements are missing.');\n      return;\n    }\n\n    const STATUS_CLASSNAMES = ['info', 'success', 'error', 'pending'];\n    const setStatus = (message = '', state = '') => {\n      status.textContent = message || '';\n      STATUS_CLASSNAMES.forEach((name) => status.classList.remove(`is-${name}`));\n      if (state) {\n        status.dataset.state = state;\n        if (STATUS_CLASSNAMES.includes(state)) {\n          status.classList.add(`is-${state}`);\n        }\n      } else {\n        status.removeAttribute('data-state');\n      }\n    };\n\n    const DEFAULT_SERVER_URL = 'http://127.0.0.1:8787';\n    const RUN_SCRIPT_PATH = '/runScript';\n\n    const normalizeServerUrl = (value) => {\n      if (value === undefined || value === null) return '';\n      let url = String(value).trim();\n      if (!url) return '';\n      if (!/^https?:\\/\\//i.test(url)) url = `http://${url}`;\n      return url.replace(/\\/+$/, '');\n    };\n    const loadServerUrl = () => {\n      try {\n        const stored = window?.localStorage?.getItem('nodeflow.psServerUrl');\n        if (stored) return normalizeServerUrl(stored) || DEFAULT_SERVER_URL;\n      } catch (error) {\n        console.warn('[ruleline] Failed to read stored PowerShell server URL', error);\n      }\n      return DEFAULT_SERVER_URL;\n    };\n    const getRunScriptEndpoint = () => {\n      const base = normalizeServerUrl(loadServerUrl()) || DEFAULT_SERVER_URL;\n      return `${base}${RUN_SCRIPT_PATH}`;\n    };\n    const invokePowerShell = async (script) => {\n      const endpoint = getRunScriptEndpoint();\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json; charset=utf-8' },\n        body: JSON.stringify({ script }),\n      });\n      let payload;\n      try {\n        payload = await response.json();\n      } catch {\n        throw new Error('PowerShell サーバーから無効な応答を受信しました。');\n      }\n      if (!response.ok) throw new Error(payload?.error || `HTTP ${response.status}`);\n      if (payload?.ok === false) {\n        const message = Array.isArray(payload?.errors) && payload.errors.length\n          ? payload.errors.join('\n')\n          : payload?.error || 'PowerShell がエラーを返しました。';\n        throw new Error(message);\n      }\n      return typeof payload?.output === 'string' ? payload.output.trim() : '';\n    };\n    const requestExcelJson = async (script) => {\n      const output = await invokePowerShell(script);\n      if (!output) return null;\n      try {\n        return JSON.parse(output);\n      } catch {\n        throw new Error('PowerShell の応答を解析できませんでした。');\n      }\n    };\n\n    const isEmptyValue = (value) =>\n      value === undefined || value === null || (typeof value === 'string' && !value.trim());\n\n    const tryParseStructured = (value) => {\n      if (typeof value !== 'string') return value;\n      const trimmed = value.trim();\n      if (!trimmed) return '';\n      if (\n        (trimmed.startsWith('{') && trimmed.endsWith('}')) ||\n        (trimmed.startsWith('[') && trimmed.endsWith(']')) ||\n        /^(true|false|null|-?\\d+(?:\\.\\d+)?)$/i.test(trimmed)\n      ) {\n        try {\n          return JSON.parse(trimmed);\n        } catch {\n          return value;\n        }\n      }\n      return value;\n    };\n    const isPlainObject = (value) => Object.prototype.toString.call(value) === '[object Object]';\n\n    const getPortValue = async (name) => {\n      const targets = Array.isArray(name) ? name.filter(Boolean) : [name].filter(Boolean);\n      if (typeof ensureAutoNodes === 'function' && targets.length) {\n        try {\n          await ensureAutoNodes(targets);\n        } catch (error) {\n          console.warn(`[ruleline] Failed to auto-update input ${targets.join(', ')}`, error);\n          throw error;\n        }\n      }\n      if (typeof resolveInput === 'function') {\n        try {\n          const raw = resolveInput(name, { preferRaw: true });\n          if (!isEmptyValue(raw)) return raw;\n          const resolved = resolveInput(name);\n          if (!isEmptyValue(resolved)) return resolved;\n        } catch (error) {\n          console.warn(`[ruleline] Failed to resolve input ${name}`, error);\n        }\n      }\n      const rawConfig = node?.config?.[`${name}__raw`];\n      if (!isEmptyValue(rawConfig)) return rawConfig;\n      const stored = node?.config?.[name];\n      if (!isEmptyValue(stored)) return stored;\n      return '';\n    };\n\n    const parseRangeInfo = (value) => {\n      const info = { address: '', workbook: '', sheet: '' };\n      const visited = new Set();\n      const assignString = (key, candidate) => {\n        if (info[key]) return;\n        if (typeof candidate === 'string') {\n          const t = candidate.trim();\n          if (t) info[key] = t;\n        }\n      };\n      const inspect = (input) => {\n        const parsed = tryParseStructured(input);\n        if (parsed === undefined || parsed === null || parsed === '') return;\n        if (typeof parsed === 'string') {\n          if (!info.address) {\n            const t = parsed.trim();\n            if (t) info.address = t;\n          }\n          return;\n        }\n        if (typeof parsed === 'number' || typeof parsed === 'boolean') return;\n        if (Array.isArray(parsed)) {\n          for (const item of parsed) {\n            if (info.address && info.workbook && info.sheet) break;\n            inspect(item);\n          }\n          return;\n        }\n        if (!isPlainObject(parsed) || visited.has(parsed)) return;\n        visited.add(parsed);\n        assignString('address', parsed.SelectionAddress__raw);\n        assignString('address', parsed.SelectionAddress);\n        assignString('address', parsed.address);\n        assignString('address', parsed.Address);\n        assignString('address', parsed.range);\n        assignString('address', parsed.Range);\n        assignString('address', parsed.targetAddress);\n        assignString('workbook', parsed.workbook);\n        assignString('workbook', parsed.Workbook);\n        assignString('workbook', parsed.workbookName);\n        assignString('workbook', parsed.WorkbookName);\n        assignString('workbook', parsed.book);\n        assignString('sheet', parsed.sheet);\n        assignString('sheet', parsed.Sheet);\n        assignString('sheet', parsed.sheetName);\n        assignString('sheet', parsed.SheetName);\n        assignString('sheet', parsed.worksheet);\n        assignString('sheet', parsed.Worksheet);\n        const nestedKeys = ['selection', 'Selection', 'target', 'Target', 'value', 'Value', 'data', 'Data', 'range', 'Range'];\n        for (const key of nestedKeys) {\n          if (info.address && info.workbook && info.sheet) break;\n          if (Object.prototype.hasOwnProperty.call(parsed, key)) inspect(parsed[key]);\n        }\n      };\n      inspect(value);\n      return info;\n    };\n\n    const parseSheetPort = (value) => {\n      const info = { sheet: '', workbook: '' };\n      const visited = new Set();\n      const assignSheet = (candidate) => {\n        if (!info.sheet && typeof candidate === 'string' && candidate.trim()) {\n          info.sheet = candidate.trim();\n        }\n      };\n      const assignBook = (candidate) => {\n        if (!info.workbook && typeof candidate === 'string' && candidate.trim()) {\n          info.workbook = candidate.trim();\n        }\n      };\n      const inspect = (input) => {\n        const parsed = tryParseStructured(input);\n        if (parsed === undefined || parsed === null || parsed === '') return;\n        if (typeof parsed === 'string') {\n          assignSheet(parsed);\n          return;\n        }\n        if (typeof parsed === 'number' || typeof parsed === 'boolean') return;\n        if (Array.isArray(parsed)) {\n          for (const item of parsed) {\n            if (info.sheet && info.workbook) break;\n            inspect(item);\n          }\n          return;\n        }\n        if (!isPlainObject(parsed) || visited.has(parsed)) return;\n        visited.add(parsed);\n        assignSheet(parsed.sheet);\n        assignSheet(parsed.Sheet);\n        assignSheet(parsed.sheetName);\n        assignSheet(parsed.SheetName);\n        assignSheet(parsed.worksheet);\n        assignSheet(parsed.Worksheet);\n        assignBook(parsed.workbook);\n        assignBook(parsed.Workbook);\n        assignBook(parsed.workbookName);\n        assignBook(parsed.WorkbookName);\n        assignBook(parsed.book);\n        assignBook(parsed.Book);\n        const nested = ['selection', 'Selection', 'target', 'Target', 'source', 'Source', 'context', 'Context', 'sheet', 'Sheet', 'worksheet', 'Worksheet'];\n        for (const key of nested) {\n          if (info.sheet && info.workbook) break;\n          if (Object.prototype.hasOwnProperty.call(parsed, key)) inspect(parsed[key]);\n        }\n      };\n      inspect(value);\n      return info;\n    };\n\n    const borderIndices = (names) => names.map((name) => `$xlBordersIndex::${name}`).join(', ');\n\n    const BORDER_STYLE_SCRIPTS = {\n      none: [],\n      outer: [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlEdgeLeft', 'xlEdgeRight', 'xlEdgeTop', 'xlEdgeBottom'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      grid: [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlEdgeLeft', 'xlEdgeRight', 'xlEdgeTop', 'xlEdgeBottom'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlInsideVertical'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlInsideHorizontal'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      'mid-x': [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlInsideHorizontal'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      'mid-y': [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlInsideVertical'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      left: [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlEdgeLeft'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      right: [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlEdgeRight'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      top: [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlEdgeTop'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      bottom: [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlEdgeBottom'])}) -LineStyle $xlLineStyle::xlContinuous -Weight $xlBorderWeight::xlThin`,\n      ],\n      'bottom-double': [\n        `  Set-BorderLines -Range $target -Indices @(${borderIndices(['xlEdgeBottom'])}) -LineStyle $xlLineStyle::xlDouble`,\n      ],\n    };\n\n    const buildBorderApplyScript = (rangeSpec, styleId) => {\n      const { addressLiteral, workbookLiteral, sheetLiteral } = rangeSpec;\n      const styleLines = BORDER_STYLE_SCRIPTS[styleId] || BORDER_STYLE_SCRIPTS.outer;\n      const lines = [\n        \"$ErrorActionPreference = 'Stop'\",\n        'Add-Type -AssemblyName Microsoft.Office.Interop.Excel',\n        'function Set-BorderLines {',\n        '  param([object]$Range, [object[]]$Indices, [object]$LineStyle, [object]$Weight = $null)',\n        '  foreach ($idx in $Indices) {',\n        '    try { $border = $Range.Borders.Item($idx) } catch { $border = $null }',\n        '    if ($null -eq $border) { continue }',\n        '    $border.LineStyle = $LineStyle',\n        '    if ($Weight -ne $null) { $border.Weight = $Weight }',\n        '    try { $border.ColorIndex = -4105 } catch { }',\n        '  }',\n        '}',\n        '$excel = $null; $workbook = $null; $sheet = $null; $target = $null;',\n        'try {',\n        \"  $excel = [Runtime.Interopservices.Marshal]::GetActiveObject('Excel.Application')\",\n        \"  if ($null -eq $excel) { throw 'Excel が見つかりません。' }\",\n      ];\n      if (workbookLiteral) {\n        lines.push(\n          '  foreach ($wb in @($excel.Workbooks)) { if ($null -ne $wb -and $wb.Name -eq ' + workbookLiteral + ') { $workbook = $wb; break } }',\n          '  if ($null -eq $workbook) { throw (\"Workbook not found: {0}\" -f ' + workbookLiteral + ') }'\n        );\n      } else {\n        lines.push('  $workbook = $excel.ActiveWorkbook');\n      }\n      lines.push('  if ($null -eq $workbook) { $workbook = $excel.ActiveWorkbook }');\n      if (sheetLiteral) {\n        lines.push(\n          '  if ($workbook -ne $null) { foreach ($ws in @($workbook.Worksheets)) { if ($null -ne $ws -and $ws.Name -eq ' + sheetLiteral + ') { $sheet = $ws; break } } }',\n          '  if ($null -eq $sheet) { throw (\"Worksheet not found: {0}\" -f ' + sheetLiteral + ') }'\n        );\n      } else {\n        lines.push('  if ($workbook -ne $null) { $sheet = $workbook.ActiveSheet }');\n      }\n      lines.push('  if ($sheet -eq $null) { try { $sheet = $excel.ActiveSheet } catch { $sheet = $null } }');\n      if (addressLiteral) {\n        lines.push(\n          '  if ($sheet -ne $null) { try { $target = $sheet.Range(' + addressLiteral + ') } catch { $target = $null } }',\n          '  if ($target -eq $null) { try { $target = $excel.Range(' + addressLiteral + ') } catch { $target = $null } }'\n        );\n      }\n      lines.push(\n        '  if ($target -eq $null) { $target = $excel.Selection }',\n        \"  if ($null -eq $target) { throw '範囲が取得できません。' }\",\n        '  $xlBordersIndex = [Microsoft.Office.Interop.Excel.XlBordersIndex]',\n        '  $xlLineStyle = [Microsoft.Office.Interop.Excel.XlLineStyle]',\n        '  $xlBorderWeight = [Microsoft.Office.Interop.Excel.XlBorderWeight]',\n        '  $target.Borders.LineStyle = $xlLineStyle::xlLineStyleNone'\n      );\n      styleLines.forEach((line) => lines.push(line));\n      lines.push(\n        '  $result = [pscustomobject]@{',\n        '    ok = $true;',\n        '    workbook = try { $workbook?.Name } catch { $null };',\n        '    sheet = try { $sheet?.Name } catch { $null };',\n        '    address = try { $target.Address() } catch { $null };',\n        \"    style = '\" + styleId.replace(\"'\", \"''\") + \"'\",\n        '  }',\n        \"} catch {\",\n        '  $result = [pscustomobject]@{ ok = $false; error = $_.Exception.Message }',\n        '} finally {',\n        '  if ($target -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($target) | Out-Null }',\n        '  if ($sheet -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($sheet) | Out-Null }',\n        '  if ($workbook -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workbook) | Out-Null }',\n        '  if ($excel -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null }',\n        '  [GC]::Collect(); [GC]::WaitForPendingFinalizers()',\n        '}',\n        '$result | ConvertTo-Json -Compress'\n      );\n      return lines.join('\n');\n    };\n\n    const BORDER_STYLES = [\n      { id: 'none', label: '罫線なし', icon: './svg/ruleline-none-icon.svg' },\n      { id: 'outer', label: '外枠', icon: './svg/ruleline-outer-icon.svg' },\n      { id: 'grid', label: '格子', icon: './svg/ruleline-grid-icon.svg' },\n      { id: 'mid-x', label: '横罫線', icon: './svg/ruleline-mid-x-icon.svg' },\n      { id: 'mid-y', label: '縦罫線', icon: './svg/ruleline-mid-y-icon.svg' },\n      { id: 'left', label: '左罫線', icon: './svg/ruleline-left-icon.svg' },\n      { id: 'right', label: '右罫線', icon: './svg/ruleline-right-icon.svg' },\n      { id: 'top', label: '上罫線', icon: './svg/ruleline-top-icon.svg' },\n      { id: 'bottom', label: '下罫線', icon: './svg/ruleline-bottom-icon.svg' },\n      { id: 'bottom-double', label: '二重下罫線', icon: './svg/ruleline-bottom-double-icon.svg' },\n    ];\n\n    const highlightActiveStyle = (styleId) => {\n      grid.querySelectorAll('button[data-style]').forEach((btn) => {\n        btn.classList.toggle('is-active', btn.dataset.style === styleId);\n      });\n    };\n\n    const setButtonsDisabled = (state) => {\n      grid.querySelectorAll('button[data-style]').forEach((btn) => {\n        btn.disabled = state;\n        btn.classList.toggle('is-disabled', state);\n      });\n    };\n\n    let isBusy = false;\n\n    const applyStyle = async (style, { silent = false } = {}) => {\n      if (!style || isBusy) {\n        return null;\n      }\n      isBusy = true;\n      setButtonsDisabled(true);\n      setStatus(`${style.label} を適用中…`, 'pending');\n      try {\n        const rangeValue = await getPortValue('Range');\n        const sheetValue = await getPortValue('Sheet');\n        const workbookValue = await getPortValue('Workbook');\n        const rangeInfo = parseRangeInfo(rangeValue);\n        const sheetInfo = parseSheetPort(sheetValue);\n        const workbookInfo = parseSheetPort(workbookValue);\n        if (sheetInfo.sheet && !rangeInfo.sheet) rangeInfo.sheet = sheetInfo.sheet;\n        if (sheetInfo.workbook && !rangeInfo.workbook) rangeInfo.workbook = sheetInfo.workbook;\n        if (workbookInfo.sheet && !rangeInfo.sheet) rangeInfo.sheet = workbookInfo.sheet;\n        if (workbookInfo.workbook && !rangeInfo.workbook) rangeInfo.workbook = workbookInfo.workbook;\n\n        const rangeSpec = {\n          addressLiteral: rangeInfo.address ? toPowerShellLiteral(rangeInfo.address) : null,\n          workbookLiteral: rangeInfo.workbook ? toPowerShellLiteral(rangeInfo.workbook) : null,\n          sheetLiteral: rangeInfo.sheet ? toPowerShellLiteral(rangeInfo.sheet) : null,\n        };\n        const script = buildBorderApplyScript(rangeSpec, style.id);\n        const data = await requestExcelJson(script);\n        if (!data?.ok) {\n          throw new Error(data?.error || '罫線の適用に失敗しました。');\n        }\n\n        const workbookName = data.workbook || rangeInfo.workbook || '';\n        const sheetName = data.sheet || rangeInfo.sheet || '';\n        const address = data.address || rangeInfo.address || '';\n\n        const setConfigPair = (key, value) => {\n          updateConfig(`${key}__raw`, value ?? '', { silent: true });\n          updateConfig(key, value ? toPowerShellLiteral(value) : '', { silent: true });\n        };\n\n        setConfigPair('LastStyle', style.id);\n        setConfigPair('LastWorkbook', workbookName);\n        setConfigPair('LastSheet', sheetName);\n        setConfigPair('LastAddress', address);\n\n        const summaryParts = [workbookName, sheetName, address].filter(Boolean);\n        const summary = summaryParts.length\n          ? `${summaryParts.join(' ')} に ${style.label} を適用しました。`\n          : `${style.label} を適用しました。`;\n        setConfigPair('LastResultMessage', summary);\n\n        highlightActiveStyle(style.id);\n        setStatus(summary, 'success');\n        return summary;\n      } catch (error) {\n        setStatus(`罫線の適用に失敗しました: ${error.message}`, 'error');\n        throw error;\n      } finally {\n        isBusy = false;\n        setButtonsDisabled(false);\n      }\n    };\n\n    const syncFromConfig = () => {\n      const lastStyle = node?.config?.LastStyle__raw || node?.config?.LastStyle || '';\n      const lastMessage = node?.config?.LastResultMessage__raw || node?.config?.LastResultMessage || '';\n      highlightActiveStyle(lastStyle);\n      if (lastMessage) {\n        setStatus(lastMessage, 'info');\n      } else {\n        setStatus('罫線スタイルを選択してください。', 'info');\n      }\n    };\n\n    BORDER_STYLES.forEach((style) => {\n      const button = document.createElement('button');\n      button.type = 'button';\n      button.className = 'border-swatch';\n      button.dataset.style = style.id;\n      button.setAttribute('aria-label', style.label);\n      button.title = style.label;\n      const img = document.createElement('img');\n      img.src = style.icon;\n      img.alt = '';\n      button.appendChild(img);\n      button.addEventListener('click', () => {\n        applyStyle(style).catch((error) => {\n          console.warn('[ruleline] Failed to apply style', error);\n        });\n      });\n      grid.appendChild(button);\n    });\n\n    syncFromConfig();\n\n    context.registerAutoExecutor?.(() => {\n      const styleId = node?.config?.LastStyle__raw || node?.config?.LastStyle;\n      const style = BORDER_STYLES.find((item) => item.id === styleId);\n      if (!style) {\n        return null;\n      }\n      return applyStyle(style);\n    });",
    "style": ".borderline-node {\n  font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Noto Sans JP\", Arial, sans-serif;\n  display: grid;\n  gap: 8px;\n}\n\n.borderline-node .palette-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.borderline-node .palette-title {\n  font-weight: 600;\n}\n\n.borderline-node .palette-status {\n  min-height: 1.5rem;\n  font-size: 0.85rem;\n  line-height: 1.2;\n}\n\n.borderline-node .palette-status[data-state=\"error\"] { color: #b00020; }\n.borderline-node .palette-status[data-state=\"success\"] { color: #137333; }\n.borderline-node .palette-status[data-state=\"pending\"] { color: #1a73e8; }\n.borderline-node .palette-status[data-state=\"info\"] { color: #5f6368; }\n\n.borderline-node .palette-frame {\n  border: 1px solid #e0e3e7;\n  border-radius: 12px;\n  padding: 10px;\n  background: #fff;\n}\n\n.borderline-node .border-grid {\n  display: grid;\n  grid-template-columns: repeat(5, 56px);\n  gap: 8px;\n  align-items: start;\n}\n\n.borderline-node .border-swatch {\n  width: 56px;\n  height: 56px;\n  border: 1px solid #dadce0;\n  border-radius: 12px;\n  background: #fff;\n  padding: 0;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  transition: border-color 120ms ease, box-shadow 120ms ease, transform 120ms ease;\n}\n\n.borderline-node .border-swatch:hover:not(:disabled) {\n  border-color: #9aa0a6;\n  transform: translateY(-1px);\n}\n\n.borderline-node .border-swatch:focus-visible {\n  outline: 2px solid #2563eb;\n  outline-offset: 2px;\n}\n\n.borderline-node .border-swatch.is-active {\n  border-color: #2563eb;\n  box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);\n}\n\n.borderline-node .border-swatch.is-disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.borderline-node .border-swatch img {\n  display: block;\n  width: 80%;\n  height: 80%;\n  object-fit: contain;\n}"
  },
  "description": "Apply preset Excel border styles to the current selection.",
  "chainExecution": false,
  "createdAt": "2025-11-06T07:36:11Z",
  "updatedAt": "2025-11-06T07:36:11Z"
}
