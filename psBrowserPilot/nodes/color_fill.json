{
    "id": "color_fill",
    "label": "Color Fill",
    "category": "Custom",
    "execution": "ui",
    "inputs": [
        "Color",
        "Sheet",
        "Range"
    ],
    "outputs": [],
    "constants": [
        {
            "key": "note",
            "type": "TextBox",
            "value": "# TODO: describe behavior"
        }
    ],
    "script": "# Use {{input.Name}} to reference incoming values,\n# {{config.key}} for constant fields, and {{output.Result}} for outputs.\n# Remove these lines and write your PowerShell snippet here.",
    "ui": {
        "markup": "<div class=\"excel-ui-node color-palette-node\" data-role=\"root\">\n  <div class=\"palette-header\">\n    <div class=\"palette-title\">Color Palette</div>\n    <div class=\"palette-status\" data-role=\"status\"></div>\n  </div>\n\n  <div class=\"palette-frame\">\n    <div class=\"palette-grid\" data-role=\"grid\">\n      <!-- SVGボタンたちがここに挿入される（+ボタンの左に追加） -->\n      <button type=\"button\" class=\"palette-add\" data-role=\"add\" aria-label=\"Add color\">\n        <span class=\"plus-icon\">＋</span>\n      </button>\n    </div>\n  </div>\n</div>\n",
        "script": "const { node, controls, updateConfig, resolveInput, ensureAutoNodes, toPowerShellLiteral } = context;\nif (!controls) return;\n\nconst grid = controls.querySelector('[data-role=\"grid\"]');\nconst addBtn = controls.querySelector('[data-role=\"add\"]');\nconst status = controls.querySelector('[data-role=\"status\"]');\n\nif (!grid || !addBtn || !status) {\n  console.warn('[color_fill] Required UI elements are missing.');\n  return;\n}\n\nconst DEFAULT_SERVER_URL = \"http://127.0.0.1:8787\";\nconst RUN_SCRIPT_PATH = \"/runScript\";\nconst swatchSet = new Set();\n\n/* ====== サーバ通信共通関数 ====== */\nconst normalizeServerUrl = (value) => {\n  if (value === undefined || value === null) return \"\";\n  let url = String(value).trim();\n  if (!url) return \"\";\n  if (!/^https?:\\/\\//i.test(url)) {\n    url = `http://${url}`;\n  }\n  return url.replace(/\\/+$/, \"\");\n};\n\nconst loadServerUrl = () => {\n  try {\n    const stored = window?.localStorage?.getItem(\"nodeflow.psServerUrl\");\n    if (stored) {\n      const normalized = normalizeServerUrl(stored);\n      return normalized || DEFAULT_SERVER_URL;\n    }\n  } catch (error) {\n    console.warn(\"Failed to read stored PowerShell server URL\", error);\n  }\n  return DEFAULT_SERVER_URL;\n};\n\nconst getRunScriptEndpoint = () => {\n  const base = normalizeServerUrl(loadServerUrl()) || DEFAULT_SERVER_URL;\n  return `${base}${RUN_SCRIPT_PATH}`;\n};\n\nconst invokePowerShell = async (script) => {\n  const endpoint = getRunScriptEndpoint();\n  const response = await fetch(endpoint, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json; charset=utf-8\" },\n    body: JSON.stringify({ script }),\n  });\n\n  let payload;\n  try {\n    payload = await response.json();\n  } catch {\n    throw new Error(\"PowerShell サーバーから無効な応答を受信しました。\");\n  }\n\n  if (!response.ok) {\n    throw new Error(payload?.error || `HTTP ${response.status}`);\n  }\n  if (payload?.ok === false) {\n    const message = Array.isArray(payload?.errors) && payload.errors.length\n      ? payload.errors.join(\"\\n\")\n      : payload?.error || \"PowerShell がエラーを返しました。\";\n    throw new Error(message);\n  }\n\n  return typeof payload?.output === \"string\" ? payload.output.trim() : \"\";\n};\n\nconst requestExcelJson = async (script) => {\n  const output = await invokePowerShell(script);\n  if (!output) return null;\n  try {\n    return JSON.parse(output);\n  } catch {\n    throw new Error(\"PowerShell の応答を解析できませんでした。\");\n  }\n};\n\n/* ====== 共通UI関数 ====== */\nconst setStatus = (message, state = \"\") => {\n  status.textContent = message || \"\";\n  status.dataset.state = state;\n};\n\nconst isEmptyValue = (value) =>\n  value === undefined ||\n  value === null ||\n  (typeof value === \"string\" && !value.trim());\n\n/* ====== 値解析ユーティリティ ====== */\nconst tryParseStructured = (value) => {\n  if (typeof value !== \"string\") return value;\n  const trimmed = value.trim();\n  if (!trimmed) return \"\";\n  if (\n    (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\n    (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\")) ||\n    /^(true|false|null)$/i.test(trimmed)\n  ) {\n    try {\n      return JSON.parse(trimmed);\n    } catch {\n      // fall through\n    }\n  }\n  return value;\n};\n\nconst isPlainObject = (value) =>\n  Object.prototype.toString.call(value) === \"[object Object]\";\n\nconst getPortValue = async (name) => {\n  const targets = Array.isArray(name) ? name.filter(Boolean) : [name].filter(Boolean);\n  if (typeof ensureAutoNodes === \"function\" && targets.length) {\n    try {\n      await ensureAutoNodes(targets);\n    } catch (error) {\n      console.warn(`[color_fill] Failed to auto-update input ${targets.join(\", \"`)}`, error);\n      throw error;\n    }\n  }\n\n  if (typeof resolveInput === \"function\") {\n    try {\n      const raw = resolveInput(name, { preferRaw: true });\n      if (!isEmptyValue(raw)) return raw;\n      const resolved = resolveInput(name);\n      if (!isEmptyValue(resolved)) return resolved;\n    } catch (error) {\n      console.warn(`[color_fill] Failed to resolve input ${name}`, error);\n    }\n  }\n\n  const rawConfig = node?.config?.[`${name}__raw`];\n  if (!isEmptyValue(rawConfig)) return rawConfig;\n\n  const stored = node?.config?.[name];\n  if (!isEmptyValue(stored)) return stored;\n\n  return \"\";\n};\n\n/* ====== 色ユーティリティ ====== */\nconst clampChannel = (value) => {\n  const num = Number(value);\n  if (!Number.isFinite(num)) {\n    throw new Error(\"RGB の値が数値ではありません。\");\n  }\n  return Math.max(0, Math.min(255, Math.round(num)));\n};\n\nconst rgbToHex = (r, g, b) =>\n  \"#\" + [r, g, b].map((v) => v.toString(16).padStart(2, \"0\")).join(\"\").toUpperCase();\n\nconst rgbToOle = (r, g, b) => r + g * 256 + b * 65536;\n\nconst hexToRgb = (hex) => {\n  const value = hex.replace(\"#\", \"\");\n  const full = value.length === 3 ? value.split(\"\").map((c) => c + c).join(\"\") : value;\n  const int = parseInt(full, 16);\n  return {\n    r: (int >> 16) & 255,\n    g: (int >> 8) & 255,\n    b: int & 255,\n  };\n};\n\nconst oleToColor = (oleValue) => {\n  const numeric = Number(oleValue);\n  if (!Number.isFinite(numeric)) {\n    throw new Error(\"OLE 色の値が不正です。\");\n  }\n  const ole = numeric >>> 0;\n  const r = ole & 255;\n  const g = (ole >>> 8) & 255;\n  const b = (ole >>> 16) & 255;\n  return { hex: rgbToHex(r, g, b), ole };\n};\n\nconst tupleToColor = (tuple) => {\n  if (!Array.isArray(tuple) || tuple.length !== 3) {\n    throw new Error(\"RGB の配列は 3 要素で指定してください。\");\n  }\n  const [r, g, b] = tuple.map(clampChannel);\n  return { hex: rgbToHex(r, g, b), ole: rgbToOle(r, g, b) };\n};\n\nconst colorFromHexString = (value) => {\n  if (typeof value !== \"string\") {\n    throw new Error(\"HEX の形式が不正です。\");\n  }\n  let hex = value.trim();\n  if (!hex) {\n    throw new Error(\"HEX の形式が不正です。\");\n  }\n  if (/^0x[0-9a-f]+$/i.test(hex)) {\n    hex = `#${hex.slice(2)}`;\n  } else if (!hex.startsWith(\"#\")) {\n    hex = `#${hex}`;\n  }\n  if (!/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(hex)) {\n    throw new Error(\"HEX の形式が不正です。\");\n  }\n  const { r, g, b } = hexToRgb(hex);\n  return { hex: rgbToHex(r, g, b), ole: rgbToOle(r, g, b) };\n};\n\nconst flattenColorInput = (input) => {\n  const value = tryParseStructured(input);\n  if (value === undefined || value === null || value === \"\") {\n    return [];\n  }\n\n  if (typeof value === \"number\" && Number.isFinite(value)) {\n    return [oleToColor(value)];\n  }\n\n  if (typeof value === \"string\") {\n    const str = value.trim();\n    if (!str) return [];\n\n    if (/^#/.test(str) || /^0x[0-9a-f]+$/i.test(str) || /^[0-9a-f]{3,6}$/i.test(str)) {\n      try {\n        return [colorFromHexString(str)];\n      } catch {\n        return [];\n      }\n    }\n\n    const rgbMatch = str.match(/^rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/i);\n    if (rgbMatch) {\n      return [tupleToColor([rgbMatch[1], rgbMatch[2], rgbMatch[3]])];\n    }\n\n    const parts = str.split(/[\\s,;]+/).filter(Boolean);\n    if (parts.length === 3 && parts.every((p) => /^-?\\d+(?:\\.\\d+)?$/.test(p))) {\n      try {\n        return [tupleToColor(parts)];\n      } catch {\n        return [];\n      }\n    }\n\n    if (parts.length > 1 && parts.every((p) => /^#?[0-9a-f]{3,6}$/i.test(p))) {\n      return parts.flatMap((p) => flattenColorInput(p));\n    }\n\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    if (value.length === 3 && value.every((v) => Number.isFinite(Number(v)))) {\n      return [tupleToColor(value)];\n    }\n    return value.flatMap((item) => flattenColorInput(item));\n  }\n\n  if (isPlainObject(value)) {\n    const results = [];\n    const directKeys = [\n      \"hex\",\n      \"Hex\",\n      \"color\",\n      \"Color\",\n      \"colour\",\n      \"Colour\",\n      \"value\",\n      \"Value\",\n    ];\n    for (const key of directKeys) {\n      if (key in value) {\n        results.push(...flattenColorInput(value[key]));\n      }\n    }\n    if (\"ole\" in value) {\n      results.push(...flattenColorInput(value.ole));\n    }\n    if (\"rgb\" in value) {\n      results.push(...flattenColorInput(value.rgb));\n    }\n    if (\"RGB\" in value) {\n      results.push(...flattenColorInput(value.RGB));\n    }\n    if ([\"r\", \"g\", \"b\"].every((k) => k in value)) {\n      results.push(tupleToColor([value.r, value.g, value.b]));\n    }\n    const nestedKeys = [\"colors\", \"Colours\", \"swatches\", \"items\", \"data\", \"list\"];\n    for (const key of nestedKeys) {\n      if (key in value) {\n        results.push(...flattenColorInput(value[key]));\n      }\n    }\n    return results;\n  }\n\n  return [];\n};\n\nconst parseColors = (value) => {\n  const colors = flattenColorInput(value);\n  if (!colors.length) {\n    throw new Error(\"Color の解釈に失敗しました（HEX または RGB を指定してください）。\");\n  }\n  const seen = new Set();\n  return colors.filter((color) => {\n    const key = String(color.ole);\n    if (!key || seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n};\n\n/* ====== Range 情報解析 ====== */\nconst parseRangeInfo = (value) => {\n  const info = { address: \"\", workbook: \"\", sheet: \"\" };\n  const visited = new Set();\n\n  const assignString = (key, candidate) => {\n    if (info[key]) return;\n    if (typeof candidate === \"string\") {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        info[key] = trimmed;\n      }\n    }\n  };\n\n  const inspect = (input) => {\n    const parsed = tryParseStructured(input);\n    if (parsed === undefined || parsed === null || parsed === \"\") {\n      return;\n    }\n\n    if (typeof parsed === \"string\") {\n      const trimmed = parsed.trim();\n      if (trimmed && !info.address) {\n        info.address = trimmed;\n      }\n      return;\n    }\n\n    if (typeof parsed === \"number\" || typeof parsed === \"boolean\") {\n      return;\n    }\n\n    if (Array.isArray(parsed)) {\n      for (const item of parsed) {\n        if (info.address && info.workbook && info.sheet) break;\n        inspect(item);\n      }\n      return;\n    }\n\n    if (!isPlainObject(parsed) || visited.has(parsed)) {\n      return;\n    }\n    visited.add(parsed);\n\n    assignString(\"address\", parsed.SelectionAddress__raw);\n    assignString(\"address\", parsed.SelectionAddress);\n    assignString(\"address\", parsed.address);\n    assignString(\"address\", parsed.Address);\n    assignString(\"address\", parsed.range);\n    assignString(\"address\", parsed.Range);\n    assignString(\"address\", parsed.targetAddress);\n\n    assignString(\"workbook\", parsed.workbook);\n    assignString(\"workbook\", parsed.Workbook);\n    assignString(\"workbook\", parsed.workbookName);\n    assignString(\"workbook\", parsed.WorkbookName);\n    assignString(\"workbook\", parsed.book);\n\n    assignString(\"sheet\", parsed.sheet);\n    assignString(\"sheet\", parsed.Sheet);\n    assignString(\"sheet\", parsed.sheetName);\n    assignString(\"sheet\", parsed.SheetName);\n    assignString(\"sheet\", parsed.worksheet);\n    assignString(\"sheet\", parsed.Worksheet);\n\n    const nestedKeys = [\n      \"selection\",\n      \"Selection\",\n      \"target\",\n      \"Target\",\n      \"value\",\n      \"Value\",\n      \"data\",\n      \"Data\",\n      \"range\",\n      \"Range\",\n    ];\n    for (const key of nestedKeys) {\n      if (info.address && info.workbook && info.sheet) break;\n      if (key in parsed) {\n        inspect(parsed[key]);\n      }\n    }\n  };\n\n  inspect(value);\n  return info;\n};\n\n\nconst parseSheetPort = (value) => {\n  const info = { sheet: \"\", workbook: \"\" };\n  const visited = new Set();\n\n  const assignSheet = (candidate) => {\n    if (info.sheet) return;\n    if (typeof candidate === \"string\") {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        info.sheet = trimmed;\n      }\n    }\n  };\n\n  const assignWorkbook = (candidate) => {\n    if (info.workbook) return;\n    if (typeof candidate === \"string\") {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        info.workbook = trimmed;\n      }\n    }\n  };\n\n  const inspect = (input) => {\n    const parsed = tryParseStructured(input);\n    if (parsed === undefined || parsed === null || parsed === \"\") {\n      return;\n    }\n\n    if (typeof parsed === \"string\") {\n      if (!info.sheet) {\n        const trimmed = parsed.trim();\n        if (trimmed) {\n          info.sheet = trimmed;\n        }\n      }\n      return;\n    }\n\n    if (typeof parsed === \"number\" || typeof parsed === \"boolean\") {\n      return;\n    }\n\n    if (Array.isArray(parsed)) {\n      for (const item of parsed) {\n        if (info.sheet && info.workbook) break;\n        inspect(item);\n      }\n      return;\n    }\n\n    if (!isPlainObject(parsed) || visited.has(parsed)) {\n      return;\n    }\n    visited.add(parsed);\n\n    assignSheet(parsed.sheet);\n    assignSheet(parsed.Sheet);\n    assignSheet(parsed.sheetName);\n    assignSheet(parsed.SheetName);\n    assignSheet(parsed.worksheet);\n    assignSheet(parsed.Worksheet);\n\n    assignWorkbook(parsed.workbook);\n    assignWorkbook(parsed.Workbook);\n    assignWorkbook(parsed.workbookName);\n    assignWorkbook(parsed.WorkbookName);\n    assignWorkbook(parsed.book);\n    assignWorkbook(parsed.Book);\n\n    const nestedKeys = [\n      \"selection\",\n      \"Selection\",\n      \"target\",\n      \"Target\",\n      \"source\",\n      \"Source\",\n      \"context\",\n      \"Context\",\n      \"sheet\",\n      \"Sheet\",\n      \"worksheet\",\n      \"Worksheet\",\n    ];\n\n    for (const key of nestedKeys) {\n      if (info.sheet && info.workbook) break;\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        inspect(parsed[key]);\n      }\n    }\n  };\n\n  inspect(value);\n  return info;\n};\n/* ====== PowerShell スクリプト生成 ====== */\nconst COLOR_HELPERS = [\n  \"function Convert-OleToHex {\",\n  \"  param([Parameter()][object]$Ole)\",\n  \"  if ($null -eq $Ole) { return $null }\",\n  \"  try {\",\n  \"    $c = [System.Drawing.ColorTranslator]::FromOle([int]$Ole)\",\n  \"    return ('#{0:X2}{1:X2}{2:X2}' -f $c.R, $c.G, $c.B)\",\n  \"  } catch { return $null }\",\n  \"}\"\n].join(\"\\n\");\n\nconst buildColorApplyScript = (rangeSpec, colorInt) => {\n  const { addressLiteral, workbookLiteral, sheetLiteral } = rangeSpec;\n  const useAddress = Boolean(addressLiteral);\n  const useWorkbook = Boolean(workbookLiteral);\n  const useSheet = Boolean(sheetLiteral);\n\n  const lines = [\n    \"$ErrorActionPreference = 'Stop'\",\n    \"Add-Type -AssemblyName System.Drawing\",\n    COLOR_HELPERS,\n    \"$excel = $null\",\n    \"$workbook = $null\",\n    \"$sheet = $null\",\n    \"$target = $null\",\n    \"try {\",\n    \"  $excel = [Runtime.Interopservices.Marshal]::GetActiveObject('Excel.Application')\",\n    \"  if ($null -eq $excel) { throw 'Excel が見つかりません。' }\",\n  ];\n\n  if (useWorkbook) {\n    lines.push(\n      \"  foreach ($wb in @($excel.Workbooks)) {\",\n      `    if ($null -ne $wb -and $wb.Name -eq ${workbookLiteral}) {`,\n      \"      $workbook = $wb\",\n      \"      break\",\n      \"    }\",\n      \"  }\",\n      `  if ($null -eq $workbook) { throw (\\\"Workbook not found: {0}\\\" -f ${workbookLiteral}) }`\n    );\n  } else {\n    lines.push(\"  $workbook = $excel.ActiveWorkbook\");\n  }\n\n  lines.push(\"  if ($null -eq $workbook) { $workbook = $excel.ActiveWorkbook }\");\n\n  if (useSheet) {\n    lines.push(\n      \"  if ($workbook -ne $null) {\",\n      \"    foreach ($ws in @($workbook.Worksheets)) {\",\n      `      if ($null -ne $ws -and $ws.Name -eq ${sheetLiteral}) {`,\n      \"        $sheet = $ws\",\n      \"        break\",\n      \"      }\",\n      \"    }\",\n      \"  }\",\n      `  if ($null -eq $sheet) { throw (\\\"Worksheet not found: {0}\\\" -f ${sheetLiteral}) }`\n    );\n  } else {\n    lines.push(\"  if ($workbook -ne $null) { $sheet = $workbook.ActiveSheet }\");\n  }\n\n  lines.push(\"  if ($sheet -eq $null) { try { $sheet = $excel.ActiveSheet } catch { $sheet = $null } }\");\n\n  if (useAddress) {\n    lines.push(\n      \"  if ($sheet -ne $null) {\",\n      \"    try {\",\n      `      $target = $sheet.Range(${addressLiteral})`,\n      \"    } catch {\",\n      \"      $target = $null\",\n      \"    }\",\n      \"  }\",\n      \"  if ($target -eq $null) {\",\n      \"    try {\",\n      `      $target = $excel.Range(${addressLiteral})`,\n      \"    } catch {\",\n      \"      $target = $null\",\n      \"    }\",\n      \"  }\"\n    );\n  }\n\n  lines.push(\n    \"  if ($target -eq $null) {\",\n    \"    $target = $excel.Selection\",\n    \"  }\",\n    \"  if ($null -eq $target) { throw '範囲が取得できません。' }\",\n    `  $target.Interior.Color = ${colorInt}`,\n    \"  $result = [pscustomobject]@{\",\n    \"    ok = $true;\",\n    \"    workbook = try { $workbook?.Name } catch { $null };\",\n    \"    sheet = try { $sheet?.Name } catch { $null };\",\n    \"    address = try { $target.Address() } catch { $null };\",\n    \"    interior_color = @{\",\n    \"      hex = Convert-OleToHex $target.Interior.Color;\",\n    \"      ole = $target.Interior.Color\",\n    \"    }\",\n    \"  }\",\n    \"} catch {\",\n    \"  $result = [pscustomobject]@{ ok = $false; error = $_.Exception.Message }\",\n    \"} finally {\",\n    \"  if ($target -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($target) | Out-Null }\",\n    \"  if ($sheet -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($sheet) | Out-Null }\",\n    \"  if ($workbook -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workbook) | Out-Null }\",\n    \"  if ($excel -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null }\",\n    \"  [GC]::Collect()\",\n    \"  [GC]::WaitForPendingFinalizers()\",\n    \"}\",\n    \"$result | ConvertTo-Json -Compress\"\n  );\n\n  return lines.join(\"\\n\");\n};\n\n/* ====== SVGテンプレート ====== */\nconst SVG_TEMPLATE = `<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 480 480\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M358.299,246.425l0,73.701l22.677,0l51.024,-48.189l0,-96.378l-25.512,-25.512l-76.535,0l62.362,62.362l-34.016,34.016Z\" style=\"fill:#5ea3d9;\"/>\n<rect x=\"46.488\" y=\"342.803\" width=\"385.512\" height=\"90.709\" style=\"fill:#f00;\"/>\n</svg>`;\n\nconst createSwatchButton = (hex, ole) => {\n  const btn = document.createElement(\"button\");\n  btn.type = \"button\";\n  btn.className = \"palette-swatch\";\n  btn.dataset.hex = hex;\n  btn.dataset.ole = String(ole);\n  btn.setAttribute(\"aria-label\", `${hex} を適用`);\n  btn.setAttribute(\"title\", hex);\n  btn.innerHTML = SVG_TEMPLATE.replace(/fill:#f00/gi, `fill:${hex}`);\n\n  btn.addEventListener(\"click\", async () => {\n    btn.disabled = true;\n    try {\n      setStatus(`${hex} を適用中…`, \"pending\");\n      const rangeValue = await getPortValue(\"Range\");\n      const sheetInput = await getPortValue(\"Sheet\");\n      const rangeInfo = parseRangeInfo(rangeValue);\n      const sheetInfo = parseSheetPort(sheetInput);\n      if (sheetInfo.sheet && !rangeInfo.sheet) {\n        rangeInfo.sheet = sheetInfo.sheet;\n      }\n      if (sheetInfo.workbook && !rangeInfo.workbook) {\n        rangeInfo.workbook = sheetInfo.workbook;\n      }\n      const rangeSpec = {\n        addressLiteral: rangeInfo.address ? toPowerShellLiteral(rangeInfo.address) : null,\n        workbookLiteral: rangeInfo.workbook ? toPowerShellLiteral(rangeInfo.workbook) : null,\n        sheetLiteral: rangeInfo.sheet ? toPowerShellLiteral(rangeInfo.sheet) : null,\n      };\n      const script = buildColorApplyScript(rangeSpec, ole);\n      const data = await requestExcelJson(script);\n      if (!data?.ok) {\n        throw new Error(data?.error || \"PowerShell 実行に失敗しました。\");\n      }\n      const labelParts = [data.workbook, data.sheet, data.address].filter(Boolean);\n      const label = labelParts.length ? labelParts.join(\" \") : \"選択範囲\";\n      setStatus(`${label} に色を適用しました。`, \"success\");\n    } catch (error) {\n      setStatus(`着色に失敗: ${error.message}`, \"error\");\n    } finally {\n      btn.disabled = false;\n    }\n  });\n\n  return btn;\n};\n\nconst addColorsFromInput = (rawValue, { replace = false } = {}) => {\n  const colors = parseColors(rawValue);\n  if (replace) {\n    grid.querySelectorAll('.palette-swatch').forEach((node) => node.remove());\n    swatchSet.clear();\n  }\n  let added = 0;\n  for (const color of colors) {\n    const key = String(color.ole);\n    if (swatchSet.has(key)) continue;\n    const swatch = createSwatchButton(color.hex, color.ole);\n    grid.insertBefore(swatch, addBtn);\n    swatchSet.add(key);\n    added += 1;\n  }\n  return { added, total: colors.length };\n};\n\n/* ====== 初期化 ====== */\nconst bootstrap = async () => {\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const { added, total } = addColorsFromInput(colorInput || \"#FF0000\", { replace: true });\n    if (added) {\n      setStatus(`${added} 色をロードしました。`, \"info\");\n    } else if (total) {\n      setStatus(\"すべて既に追加済みの色です。\", \"info\");\n    }\n  } catch (error) {\n    grid.querySelectorAll('.palette-swatch').forEach((node) => node.remove());\n    swatchSet.clear();\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n};\n\n/* ====== +ボタン押下 ====== */\naddBtn.addEventListener(\"click\", async () => {\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const { added, total } = addColorsFromInput(colorInput || \"#FF0000\");\n    if (added) {\n      setStatus(`${added} 色を追加しました。`, \"success\");\n    } else if (total) {\n      setStatus(\"すべて既に追加済みの色です。\", \"info\");\n    }\n  } catch (error) {\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n});\n\nbootstrap();\n",
        "style": ".color-palette-node {\n  font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Noto Sans JP\", Arial, sans-serif;\n  display: grid;\n  gap: 8px;\n}\n\n.palette-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.palette-title {\n  font-weight: 600;\n}\n\n.palette-status[data-state=\"error\"] { color: #b00020; }\n.palette-status[data-state=\"success\"] { color: #137333; }\n.palette-status[data-state=\"pending\"] { color: #1a73e8; }\n.palette-status[data-state=\"info\"] { color: #5f6368; }\n\n.palette-frame {\n  border: 1px solid #e0e3e7;\n  border-radius: 12px; /* 角R */\n  padding: 10px;\n  background: #fff;\n}\n\n.palette-grid {\n  display: grid;\n  grid-template-columns: repeat(6, 56px); /* 6列 */\n  gap: 8px;\n  align-items: start;\n}\n\n.palette-add {\n  width: 56px;\n  height: 56px;\n  border: 1px dashed #9aa0a6;\n  border-radius: 12px;\n  background: #f8f9fa;\n  cursor: pointer;\n  display: inline-grid;\n  place-items: center;\n}\n\n.palette-add:hover { background: #f1f3f4; }\n.plus-icon { font-size: 20px; line-height: 1; }\n\n.palette-swatch {\n  width: 56px;\n  height: 56px;\n  border: 1px solid #dadce0;\n  border-radius: 12px;\n  background: #fff;\n  padding: 0;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n.palette-swatch svg {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n"
    },
    "description": "Excel のセルを塗りつぶすためのカラーパレットを生成し、複数形式の色情報に対応した UI ノードです。",
    "createdAt": "2025-11-04T04:00:35.843Z",
    "updatedAt": "2025-11-04T04:39:44Z"
}