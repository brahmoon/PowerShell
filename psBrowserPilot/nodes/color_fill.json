{
    "id":  "color_fill",
    "label":  "Color Fill",
    "category":  "Custom",
    "execution":  "ui",
    "inputs":  [
                   "Color",
                   "Sheet",
                   "Range"
               ],
    "outputs":  [

                ],
    "constants":  [
                      {
                          "key":  "note",
                          "type":  "TextBox",
                          "value":  "# TODO: describe behavior"
                      }
                  ],
    "script":  "# Use {{input.Name}} to reference incoming values,\n# {{config.key}} for constant fields, and {{output.Result}} for outputs.\n# Remove these lines and write your PowerShell snippet here.",
    "ui":  {
               "markup":  "\u003cdiv class=\"excel-ui-node color-palette-node\" data-role=\"root\"\u003e\n  \u003cdiv class=\"palette-header\"\u003e\n    \u003cdiv class=\"palette-title\"\u003eColor Palette\u003c/div\u003e\n    \u003cdiv class=\"palette-status\" data-role=\"status\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\n  \u003cdiv class=\"palette-frame\"\u003e\n    \u003cdiv class=\"palette-grid\" data-role=\"grid\"\u003e\n      \u003c!-- SVGボタンたちがここに挿入される（+ボタンの左に追加） --\u003e\n      \u003cbutton type=\"button\" class=\"palette-add\" data-role=\"add\" aria-label=\"Add color\"\u003e\n        \u003cspan class=\"plus-icon\"\u003e＋\u003c/span\u003e\n      \u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n",
               "script":  "const { node, controls, updateConfig, resolveInput, ensureAutoNodes, toPowerShellLiteral } = context;\nif (!controls) return;\n\nconst grid = controls.querySelector(\u0027[data-role=\"grid\"]\u0027);\nconst addBtn = controls.querySelector(\u0027[data-role=\"add\"]\u0027);\nconst status = controls.querySelector(\u0027[data-role=\"status\"]\u0027);\n\nif (!grid || !addBtn || !status) {\n  console.warn(\u0027[color_fill] Required UI elements are missing.\u0027);\n  return;\n}\n\n/* ========= 基本UI ========= */\nconst STATUS_CLASSNAMES = [\"info\", \"success\", \"error\"];\nconst setStatus = (message = \"\", state = \"\") =\u003e {\n  if (!status) return;\n  const text = typeof message === \"string\" ? message : \"\";\n  const normalized = typeof state === \"string\" ? state.trim() : \"\";\n  status.textContent = text;\n  STATUS_CLASSNAMES.forEach((name) =\u003e status.classList.remove(`is-${name}`));\n  if (normalized) {\n    status.setAttribute(\"data-state\", normalized);\n    if (STATUS_CLASSNAMES.includes(normalized)) {\n      status.classList.add(`is-${normalized}`);\n    }\n  } else {\n    status.removeAttribute(\"data-state\");\n  }\n};\n\nconst DEFAULT_SERVER_URL = \"http://127.0.0.1:8787\";\nconst RUN_SCRIPT_PATH = \"/runScript\";\n\n/* ========= パレット状態 ========= */\nconst swatchSet = new Set();\nconst paletteMap = new Map();\nconst PALETTE_CONFIG_KEY = \"colorPalette\";\nlet swatchMenu = null;\nlet swatchMenuTargetKey = null;\nconst root = controls.querySelector(\u0027[data-role=\"root\"]\u0027) || controls;\n\n/* ========= 便利関数 ========= */\nconst isEmptyValue = (value) =\u003e\n  value === undefined || value === null || (typeof value === \"string\" \u0026\u0026 !value.trim());\n\nconst tryParseStructured = (value) =\u003e {\n  if (typeof value !== \"string\") return value;\n  const trimmed = value.trim();\n  if (!trimmed) return \"\";\n  if (\n    (trimmed.startsWith(\"{\") \u0026\u0026 trimmed.endsWith(\"}\")) ||\n    (trimmed.startsWith(\"[\") \u0026\u0026 trimmed.endsWith(\"]\")) ||\n    /^(true|false|null|-?\\d+(?:\\.\\d+)?)$/i.test(trimmed)\n  ) {\n    try { return JSON.parse(trimmed); } catch {}\n  }\n  return value;\n};\nconst isPlainObject = (value) =\u003e Object.prototype.toString.call(value) === \"[object Object]\";\n\n/* ========= 入力ポートの解決 ========= */\nconst getPortValue = async (name) =\u003e {\n  const targets = Array.isArray(name) ? name.filter(Boolean) : [name].filter(Boolean);\n  if (typeof ensureAutoNodes === \"function\" \u0026\u0026 targets.length) {\n    try {\n      await ensureAutoNodes(targets);\n    } catch (error) {\n      console.warn(`[color_fill] Failed to auto-update input ${targets.join(\", \")}`, error);\n      throw error;\n    }\n  }\n  if (typeof resolveInput === \"function\") {\n    try {\n      const raw = resolveInput(name, { preferRaw: true });\n      if (!isEmptyValue(raw)) return raw;\n      const resolved = resolveInput(name);\n      if (!isEmptyValue(resolved)) return resolved;\n    } catch (error) {\n      console.warn(`[color_fill] Failed to resolve input ${name}`, error);\n    }\n  }\n  const rawConfig = node?.config?.[`${name}__raw`];\n  if (!isEmptyValue(rawConfig)) return rawConfig;\n\n  const stored = node?.config?.[name];\n  if (!isEmptyValue(stored)) return stored;\n\n  return \"\";\n};\n\n/* ========= サーバ通信 ========= */\nconst normalizeServerUrl = (value) =\u003e {\n  if (value === undefined || value === null) return \"\";\n  let url = String(value).trim();\n  if (!url) return \"\";\n  if (!/^https?:\\/\\//i.test(url)) url = `http://${url}`;\n  return url.replace(/\\/+$/, \"\");\n};\nconst loadServerUrl = () =\u003e {\n  try {\n    const stored = window?.localStorage?.getItem(\"nodeflow.psServerUrl\");\n    if (stored) return normalizeServerUrl(stored) || DEFAULT_SERVER_URL;\n  } catch (error) {\n    console.warn(\"Failed to read stored PowerShell server URL\", error);\n  }\n  return DEFAULT_SERVER_URL;\n};\nconst getRunScriptEndpoint = () =\u003e {\n  const base = normalizeServerUrl(loadServerUrl()) || DEFAULT_SERVER_URL;\n  return `${base}${RUN_SCRIPT_PATH}`;\n};\nconst invokePowerShell = async (script) =\u003e {\n  const endpoint = getRunScriptEndpoint();\n  const response = await fetch(endpoint, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json; charset=utf-8\" },\n    body: JSON.stringify({ script }),\n  });\n  let payload;\n  try {\n    payload = await response.json();\n  } catch {\n    throw new Error(\"PowerShell サーバーから無効な応答を受信しました。\");\n  }\n  if (!response.ok) throw new Error(payload?.error || `HTTP ${response.status}`);\n  if (payload?.ok === false) {\n    const message = Array.isArray(payload?.errors) \u0026\u0026 payload.errors.length\n      ? payload.errors.join(\"\\n\")\n      : payload?.error || \"PowerShell がエラーを返しました。\";\n    throw new Error(message);\n  }\n  return typeof payload?.output === \"string\" ? payload.output.trim() : \"\";\n};\nconst requestExcelJson = async (script) =\u003e {\n  const output = await invokePowerShell(script);\n  if (!output) return null;\n  try { return JSON.parse(output); }\n  catch { throw new Error(\"PowerShell の応答を解析できませんでした。\"); }\n};\n\n/* ========= 色ユーティリティ ========= */\nconst clampChannel = (value) =\u003e {\n  const num = Number(value);\n  if (!Number.isFinite(num)) throw new Error(\"RGB の値が数値ではありません。\");\n  return Math.max(0, Math.min(255, Math.round(num)));\n};\nconst rgbToHex = (r, g, b) =\u003e\n  \"#\" + [r, g, b].map((v) =\u003e v.toString(16).padStart(2, \"0\")).join(\"\").toUpperCase();\nconst rgbToOle = (r, g, b) =\u003e r + g * 256 + b * 65536;\nconst hexToRgb = (hex) =\u003e {\n  const value = hex.replace(\"#\", \"\");\n  const full = value.length === 3 ? value.split(\"\").map((c) =\u003e c + c).join(\"\") : value;\n  const int = parseInt(full, 16);\n  return { r: (int \u003e\u003e 16) \u0026 255, g: (int \u003e\u003e 8) \u0026 255, b: int \u0026 255 };\n};\nconst oleToColor = (oleValue) =\u003e {\n  const numeric = Number(oleValue);\n  if (!Number.isFinite(numeric)) throw new Error(\"OLE 色の値が不正です。\");\n  const ole = numeric \u003e\u003e\u003e 0;\n  const r = ole \u0026 255, g = (ole \u003e\u003e\u003e 8) \u0026 255, b = (ole \u003e\u003e\u003e 16) \u0026 255;\n  return { hex: rgbToHex(r, g, b), ole };\n};\nconst tupleToColor = (tuple) =\u003e {\n  if (!Array.isArray(tuple) || tuple.length !== 3) throw new Error(\"RGB の配列は 3 要素で指定してください。\");\n  const [r, g, b] = tuple.map(clampChannel);\n  return { hex: rgbToHex(r, g, b), ole: rgbToOle(r, g, b) };\n};\nconst colorFromHexString = (value) =\u003e {\n  if (typeof value !== \"string\") throw new Error(\"HEX の形式が不正です。\");\n  let hex = value.trim();\n  if (!hex) throw new Error(\"HEX の形式が不正です。\");\n  if (/^0x[0-9a-f]+$/i.test(hex)) hex = `#${hex.slice(2)}`;\n  else if (!hex.startsWith(\"#\")) hex = `#${hex}`;\n  if (!/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(hex)) throw new Error(\"HEX の形式が不正です。\");\n  const { r, g, b } = hexToRgb(hex);\n  return { hex: rgbToHex(r, g, b), ole: rgbToOle(r, g, b) };\n};\nconst flattenColorInput = (input) =\u003e {\n  const value = tryParseStructured(input);\n  if (value === undefined || value === null || value === \"\") return [];\n\n  if (typeof value === \"number\" \u0026\u0026 Number.isFinite(value)) return [oleToColor(value)];\n\n  if (typeof value === \"string\") {\n    const str = value.trim();\n    if (!str) return [];\n    if (/^#/.test(str) || /^0x[0-9a-f]+$/i.test(str) || /^[0-9a-f]{3,6}$/i.test(str)) {\n      try { return [colorFromHexString(str)]; } catch { return []; }\n    }\n    const rgbMatch = str.match(/^rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/i);\n    if (rgbMatch) return [tupleToColor([rgbMatch[1], rgbMatch[2], rgbMatch[3]])];\n    const parts = str.split(/[\\s,;]+/).filter(Boolean);\n    if (parts.length === 3 \u0026\u0026 parts.every((p) =\u003e /^-?\\d+(?:\\.\\d+)?$/.test(p))) {\n      try { return [tupleToColor(parts)]; } catch { return []; }\n    }\n    if (parts.length \u003e 1 \u0026\u0026 parts.every((p) =\u003e /^#?[0-9a-f]{3,6}$/i.test(p))) {\n      return parts.flatMap((p) =\u003e flattenColorInput(p));\n    }\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    if (value.length === 3 \u0026\u0026 value.every((v) =\u003e Number.isFinite(Number(v)))) {\n      return [tupleToColor(value)];\n    }\n    return value.flatMap((item) =\u003e flattenColorInput(item));\n  }\n\n  if (isPlainObject(value)) {\n    const results = [];\n    const directKeys = [\"hex\",\"Hex\",\"color\",\"Color\",\"colour\",\"Colour\",\"value\",\"Value\"];\n    for (const key of directKeys) if (key in value) results.push(...flattenColorInput(value[key]));\n    if (\"ole\" in value) results.push(...flattenColorInput(value.ole));\n    if (\"rgb\" in value) results.push(...flattenColorInput(value.rgb));\n    if (\"RGB\" in value) results.push(...flattenColorInput(value.RGB));\n    if ([\"r\",\"g\",\"b\"].every(k =\u003e k in value)) results.push(tupleToColor([value.r, value.g, value.b]));\n    const nestedKeys = [\"colors\",\"Colours\",\"swatches\",\"items\",\"data\",\"list\"];\n    for (const key of nestedKeys) if (key in value) results.push(...flattenColorInput(value[key]));\n    return results;\n  }\n\n  return [];\n};\nconst parseColors = (value) =\u003e {\n  const colors = flattenColorInput(value);\n  if (!colors.length) throw new Error(\"Color の解釈に失敗しました（HEX / rgb(r,g,b) / [r,g,b] / OLE 対応）。\");\n  const seen = new Set();\n  return colors.filter((c) =\u003e {\n    const k = String(c.ole);\n    if (!k || seen.has(k)) return false;\n    seen.add(k);\n    return true;\n  });\n};\n\n/* ========= Range/Sheet 解析（任意） ========= */\nconst parseRangeInfo = (value) =\u003e {\n  const info = { address: \"\", workbook: \"\", sheet: \"\" };\n  const visited = new Set();\n  const assignString = (key, candidate) =\u003e {\n    if (info[key]) return;\n    if (typeof candidate === \"string\") {\n      const t = candidate.trim(); if (t) info[key] = t;\n    }\n  };\n  const inspect = (input) =\u003e {\n    const parsed = tryParseStructured(input);\n    if (parsed === undefined || parsed === null || parsed === \"\") return;\n\n    if (typeof parsed === \"string\") {\n      if (!info.address) { const t = parsed.trim(); if (t) info.address = t; }\n      return;\n    }\n    if (typeof parsed === \"number\" || typeof parsed === \"boolean\") return;\n\n    if (Array.isArray(parsed)) { for (const i of parsed) { if (info.address\u0026\u0026info.workbook\u0026\u0026info.sheet) break; inspect(i);} return; }\n\n    if (!isPlainObject(parsed) || visited.has(parsed)) return;\n    visited.add(parsed);\n\n    assignString(\"address\", parsed.SelectionAddress__raw);\n    assignString(\"address\", parsed.SelectionAddress);\n    assignString(\"address\", parsed.address);\n    assignString(\"address\", parsed.Address);\n    assignString(\"address\", parsed.range);\n    assignString(\"address\", parsed.Range);\n    assignString(\"address\", parsed.targetAddress);\n\n    assignString(\"workbook\", parsed.workbook);\n    assignString(\"workbook\", parsed.Workbook);\n    assignString(\"workbook\", parsed.workbookName);\n    assignString(\"workbook\", parsed.WorkbookName);\n    assignString(\"workbook\", parsed.book);\n\n    assignString(\"sheet\", parsed.sheet);\n    assignString(\"sheet\", parsed.Sheet);\n    assignString(\"sheet\", parsed.sheetName);\n    assignString(\"sheet\", parsed.SheetName);\n    assignString(\"sheet\", parsed.worksheet);\n    assignString(\"sheet\", parsed.Worksheet);\n\n    const nestedKeys = [\"selection\",\"Selection\",\"target\",\"Target\",\"value\",\"Value\",\"data\",\"Data\",\"range\",\"Range\"];\n    for (const key of nestedKeys) { if (info.address\u0026\u0026info.workbook\u0026\u0026info.sheet) break; if (key in parsed) inspect(parsed[key]); }\n  };\n  inspect(value);\n  return info;\n};\nconst parseSheetPort = (value) =\u003e {\n  const info = { sheet: \"\", workbook: \"\" };\n  const visited = new Set();\n  const assignSheet = (c) =\u003e { if (!info.sheet \u0026\u0026 typeof c===\"string\" \u0026\u0026 c.trim()) info.sheet = c.trim(); };\n  const assignBook  = (c) =\u003e { if (!info.workbook \u0026\u0026 typeof c===\"string\" \u0026\u0026 c.trim()) info.workbook = c.trim(); };\n  const inspect = (input) =\u003e {\n    const parsed = tryParseStructured(input);\n    if (parsed === undefined || parsed === null || parsed === \"\") return;\n    if (typeof parsed === \"string\") { assignSheet(parsed); return; }\n    if (typeof parsed === \"number\" || typeof parsed === \"boolean\") return;\n    if (Array.isArray(parsed)) { for (const i of parsed) { if (info.sheet\u0026\u0026info.workbook) break; inspect(i);} return; }\n    if (!isPlainObject(parsed) || visited.has(parsed)) return;\n    visited.add(parsed);\n\n    assignSheet(parsed.sheet); assignSheet(parsed.Sheet); assignSheet(parsed.sheetName);\n    assignSheet(parsed.SheetName); assignSheet(parsed.worksheet); assignSheet(parsed.Worksheet);\n\n    assignBook(parsed.workbook); assignBook(parsed.Workbook); assignBook(parsed.workbookName);\n    assignBook(parsed.WorkbookName); assignBook(parsed.book); assignBook(parsed.Book);\n\n    const nested = [\"selection\",\"Selection\",\"target\",\"Target\",\"source\",\"Source\",\"context\",\"Context\",\"sheet\",\"Sheet\",\"worksheet\",\"Worksheet\"];\n    for (const k of nested) { if (info.sheet\u0026\u0026info.workbook) break; if (Object.prototype.hasOwnProperty.call(parsed,k)) inspect(parsed[k]); }\n  };\n  inspect(value);\n  return info;\n};\n\n/* ========= PowerShell スクリプト生成 ========= */\nconst COLOR_HELPERS = [\n  \"function Convert-OleToHex {\",\n  \"  param([Parameter()][object]$Ole)\",\n  \"  if ($null -eq $Ole) { return $null }\",\n  \"  try { $c = [System.Drawing.ColorTranslator]::FromOle([int]$Ole);\",\n  \"    return (\u0027#{0:X2}{1:X2}{2:X2}\u0027 -f $c.R, $c.G, $c.B) }\",\n  \"  catch { return $null }\",\n  \"}\"\n].join(\"\\n\");\n\nconst buildColorApplyScript = (rangeSpec, colorInt) =\u003e {\n  const { addressLiteral, workbookLiteral, sheetLiteral } = rangeSpec;\n  const useAddress = Boolean(addressLiteral);\n  const useWorkbook = Boolean(workbookLiteral);\n  const useSheet = Boolean(sheetLiteral);\n\n  const lines = [\n    \"$ErrorActionPreference = \u0027Stop\u0027\",\n    \"Add-Type -AssemblyName System.Drawing\",\n    COLOR_HELPERS,\n    \"$excel = $null; $workbook = $null; $sheet = $null; $target = $null;\",\n    \"try {\",\n    \"  $excel = [Runtime.Interopservices.Marshal]::GetActiveObject(\u0027Excel.Application\u0027)\",\n    \"  if ($null -eq $excel) { throw \u0027Excel が見つかりません。\u0027 }\",\n  ];\n  if (useWorkbook) {\n    lines.push(\n      \"  foreach ($wb in @($excel.Workbooks)) { if ($null -ne $wb -and $wb.Name -eq \" + workbookLiteral + \") { $workbook = $wb; break } }\",\n      \"  if ($null -eq $workbook) { throw (\\\"Workbook not found: {0}\\\" -f \" + workbookLiteral + \") }\"\n    );\n  } else {\n    lines.push(\"  $workbook = $excel.ActiveWorkbook\");\n  }\n  lines.push(\"  if ($null -eq $workbook) { $workbook = $excel.ActiveWorkbook }\");\n\n  if (useSheet) {\n    lines.push(\n      \"  if ($workbook -ne $null) { foreach ($ws in @($workbook.Worksheets)) { if ($null -ne $ws -and $ws.Name -eq \" + sheetLiteral + \") { $sheet = $ws; break } } }\",\n      \"  if ($null -eq $sheet) { throw (\\\"Worksheet not found: {0}\\\" -f \" + sheetLiteral + \") }\"\n    );\n  } else {\n    lines.push(\"  if ($workbook -ne $null) { $sheet = $workbook.ActiveSheet }\");\n  }\n  lines.push(\"  if ($sheet -eq $null) { try { $sheet = $excel.ActiveSheet } catch { $sheet = $null } }\");\n\n  if (useAddress) {\n    lines.push(\n      \"  if ($sheet -ne $null) { try { $target = $sheet.Range(\" + addressLiteral + \") } catch { $target = $null } }\",\n      \"  if ($target -eq $null) { try { $target = $excel.Range(\" + addressLiteral + \") } catch { $target = $null } }\"\n    );\n  }\n  lines.push(\n    \"  if ($target -eq $null) { $target = $excel.Selection }\",\n    \"  if ($null -eq $target) { throw \u0027範囲が取得できません。\u0027 }\",\n    \"  $target.Interior.Color = \" + colorInt,\n    \"  $result = [pscustomobject]@{\",\n    \"    ok = $true;\",\n    \"    workbook = try { $workbook?.Name } catch { $null };\",\n    \"    sheet = try { $sheet?.Name } catch { $null };\",\n    \"    address = try { $target.Address() } catch { $null };\",\n    \"    interior_color = @{ hex = Convert-OleToHex $target.Interior.Color; ole = $target.Interior.Color }\",\n    \"  }\",\n    \"} catch {\",\n    \"  $result = [pscustomobject]@{ ok = $false; error = $_.Exception.Message }\",\n    \"} finally {\",\n    \"  if ($target -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($target) | Out-Null }\",\n    \"  if ($sheet -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($sheet) | Out-Null }\",\n    \"  if ($workbook -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workbook) | Out-Null }\",\n    \"  if ($excel -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null }\",\n    \"  [GC]::Collect(); [GC]::WaitForPendingFinalizers()\",\n    \"}\",\n    \"$result | ConvertTo-Json -Compress\"\n  );\n  return lines.join(\"\\n\");\n};\n\n/* ========= SVG（黒パスを明示、赤rectを色差し替え） ========= */\nconst SVG_TEMPLATE = `\u003csvg width=\"100%\" height=\"100%\" viewBox=\"0 0 480 480\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\n  \u003cpath d=\"M358.299,246.425l0,73.701l22.677,0l51.024,-48.189l0,-96.378l-25.512,-25.512l-76.535,0l62.362,62.362l-34.016,34.016Z\" fill=\"#5ea3d9\"/\u003e\n  \u003cpath d=\"M261.921,195.402l-22.677,0l0,-124.724l-56.693,0l0,102.047l-22.677,0l0,-124.724l102.047,0l0,147.402Z\" fill=\"#000000\"/\u003e\n  \u003cpath d=\"M193.89,342.803l-106.906,-113.386l163.599,-158.74l141.732,141.732l-130.394,130.394l-68.031,-0Zm22.677,-22.677l22.677,0l107.717,-107.717l-96.378,-96.378l-118.244,113.386l84.229,90.709Z\" fill=\"#000000\"/\u003e\n  \u003crect x=\"46.488\" y=\"342.803\" width=\"385.512\" height=\"90.709\" style=\"fill:#f00;\"/\u003e\n\u003c/svg\u003e`;\n\n/* ========= 右クリックメニュー ========= */\nconst ensureSwatchMenu = () =\u003e {\n  if (swatchMenu) return swatchMenu;\n  if (!root) return null;\n  const menu = document.createElement(\"div\");\n  menu.className = \"palette-swatch-menu is-hidden\";\n  menu.tabIndex = -1;\n  menu.addEventListener(\"contextmenu\", (e) =\u003e e.preventDefault());\n  menu.addEventListener(\"pointerdown\", (e) =\u003e e.stopPropagation());\n  const deleteBtn = document.createElement(\"button\");\n  deleteBtn.type = \"button\";\n  deleteBtn.className = \"palette-swatch-menu__item\";\n  deleteBtn.textContent = \"削除\";\n  deleteBtn.addEventListener(\"click\", () =\u003e {\n    if (!swatchMenuTargetKey) return;\n    const removed = removeSwatchByKey(swatchMenuTargetKey);\n    hideSwatchMenu();\n    if (removed) setStatus(`${removed.hex} を削除しました。`, \"info\");\n  });\n  menu.appendChild(deleteBtn);\n  root.appendChild(menu);\n  swatchMenu = menu;\n  return menu;\n};\nconst hideSwatchMenu = () =\u003e {\n  if (!swatchMenu) return;\n  if (!swatchMenu.classList.contains(\"is-hidden\")) swatchMenu.classList.add(\"is-hidden\");\n  swatchMenuTargetKey = null;\n};\nconst openSwatchMenu = (event, key) =\u003e {\n  event.preventDefault();\n  event.stopPropagation();\n  const menu = ensureSwatchMenu();\n  if (!menu || !root) return;\n  swatchMenuTargetKey = key;\n  menu.classList.remove(\"is-hidden\");\n  menu.style.left = \"0px\";\n  menu.style.top = \"0px\";\n  const rootRect = root.getBoundingClientRect();\n  const menuRect = menu.getBoundingClientRect();\n  let left = event.clientX - rootRect.left;\n  let top = event.clientY - rootRect.top;\n  const maxLeft = Math.max(0, rootRect.width - menuRect.width - 4);\n  const maxTop = Math.max(0, rootRect.height - menuRect.height - 4);\n  left = Math.max(4, Math.min(left, maxLeft));\n  top = Math.max(4, Math.min(top, maxTop));\n  menu.style.left = `${left}px`;\n  menu.style.top = `${top}px`;\n  menu.focus({ preventScroll: true });\n};\n\n/* ========= スウォッチ生成 ========= */\nconst createSwatchButton = (hex, ole) =\u003e {\n  const key = String(ole);\n  const btn = document.createElement(\"button\");\n  btn.type = \"button\";\n  btn.className = \"palette-swatch\";\n  btn.dataset.hex = hex;\n  btn.dataset.ole = String(ole);\n  btn.dataset.key = key;\n  btn.setAttribute(\"aria-label\", `${hex} を適用`);\n  btn.setAttribute(\"title\", hex);\n  btn.innerHTML = SVG_TEMPLATE.replace(/fill:#f00/gi, `fill:${hex}`);\n\n  btn.addEventListener(\"click\", async () =\u003e {\n    hideSwatchMenu();\n    btn.disabled = true;\n    try {\n      setStatus(`${hex} を適用中…`, \"pending\");\n      const rangeValue = await getPortValue(\"Range\");\n      const sheetInput = await getPortValue(\"Sheet\"); // 任意\n\n      const rangeInfo = parseRangeInfo(rangeValue);\n      const sheetInfo = parseSheetPort(sheetInput);\n      if (sheetInfo.sheet \u0026\u0026 !rangeInfo.sheet) rangeInfo.sheet = sheetInfo.sheet;\n      if (sheetInfo.workbook \u0026\u0026 !rangeInfo.workbook) rangeInfo.workbook = sheetInfo.workbook;\n\n      const rangeSpec = {\n        addressLiteral: rangeInfo.address ? toPowerShellLiteral(rangeInfo.address) : null,\n        workbookLiteral: rangeInfo.workbook ? toPowerShellLiteral(rangeInfo.workbook) : null,\n        sheetLiteral: rangeInfo.sheet ? toPowerShellLiteral(rangeInfo.sheet) : null,\n      };\n      const script = buildColorApplyScript(rangeSpec, ole);\n      const data = await requestExcelJson(script);\n      if (!data?.ok) throw new Error(data?.error || \"PowerShell 実行に失敗しました。\");\n      const label = [data.workbook, data.sheet, data.address].filter(Boolean).join(\" \") || \"選択範囲\";\n      setStatus(`${label} に色を適用しました。`, \"success\");\n    } catch (error) {\n      setStatus(`着色に失敗: ${error.message}`, \"error\");\n    } finally {\n      btn.disabled = false;\n    }\n  });\n  btn.addEventListener(\"contextmenu\", (e) =\u003e openSwatchMenu(e, key));\n  return btn;\n};\n\n/* ========= スウォッチ適用/保存 ========= */\nconst persistPalette = ({ silent = false } = {}) =\u003e {\n  const payload = Array.from(paletteMap.values()).filter((item) =\u003e {\n    const hex = typeof item?.hex === \"string\" ? item.hex.trim() : \"\";\n    const hasOle = item?.ole !== undefined \u0026\u0026 item?.ole !== null;\n    return hex \u0026\u0026 hasOle;\n  });\n  const serialized = payload.length ? JSON.stringify(payload) : \"\";\n  updateConfig(PALETTE_CONFIG_KEY, serialized, { silent });\n};\nconst clearSwatches = ({ persist = false, silent = false } = {}) =\u003e {\n  grid.querySelectorAll(\u0027.palette-swatch\u0027).forEach((n) =\u003e n.remove());\n  swatchSet.clear(); paletteMap.clear(); hideSwatchMenu();\n  if (persist) persistPalette({ silent });\n};\nconst removeSwatchByKey = (key) =\u003e {\n  if (key === undefined || key === null) return null;\n  const stringKey = String(key);\n  const entry = paletteMap.get(stringKey);\n  if (!entry) return null;\n  const swatch = grid.querySelector(`.palette-swatch[data-key=\"${stringKey}\"]`);\n  if (swatch) swatch.remove();\n  swatchSet.delete(stringKey); paletteMap.delete(stringKey); persistPalette();\n  return entry;\n};\nconst applyColors = (colors, { replace = false, persist = true, silentPersist = false } = {}) =\u003e {\n  const list = Array.isArray(colors) ? colors : [];\n  if (replace) clearSwatches({ persist: false });\n  let added = 0;\n  for (const item of list) {\n    if (!item) continue;\n    const hex = typeof item.hex === \"string\" ? item.hex.trim() : \"\";\n    const ole = item.ole;\n    const hasOle = ole !== undefined \u0026\u0026 ole !== null;\n    if (!hex || !hasOle) continue;\n    const key = String(ole);\n    if (swatchSet.has(key)) continue;\n    const swatch = createSwatchButton(hex, ole);\n    grid.insertBefore(swatch, addBtn);\n    swatchSet.add(key);\n    paletteMap.set(key, { hex, ole });\n    added += 1;\n  }\n  if (persist \u0026\u0026 (replace || added)) persistPalette({ silent: silentPersist });\n  return { added, total: list.length };\n};\nconst addColorsFromInput = (rawValue, { replace = false, persist = true, silentPersist = false } = {}) =\u003e {\n  if (isEmptyValue(rawValue)) {\n    if (replace) clearSwatches({ persist, silent: silentPersist });\n    return { added: 0, total: 0 };\n  }\n  const colors = parseColors(rawValue);\n  return applyColors(colors, { replace, persist, silentPersist });\n};\nconst loadStoredPalette = () =\u003e {\n  const raw = node?.config?.[PALETTE_CONFIG_KEY];\n  if (typeof raw !== \"string\") return [];\n  const t = raw.trim(); if (!t) return [];\n  try {\n    const parsed = JSON.parse(t);\n    if (!Array.isArray(parsed)) return [];\n    return parsed.map((item) =\u003e {\n      if (!item) return null;\n      const hex = typeof item.hex === \"string\" ? item.hex.trim() : \"\";\n      const ole = item.ole;\n      const hasOle = ole !== undefined \u0026\u0026 ole !== null;\n      if (!hex || !hasOle) return null;\n      return { hex, ole };\n    }).filter(Boolean);\n  } catch (e) {\n    console.warn(\u0027[color_fill] Failed to parse stored palette\u0027, e);\n    return [];\n  }\n};\n\n/* ========= ドキュメントイベント ========= */\nconst documentPointerDownHandler = (event) =\u003e {\n  if (!swatchMenu || swatchMenu.classList.contains(\"is-hidden\")) return;\n  const target = event.target;\n  if (!target || !(target instanceof Node)) { hideSwatchMenu(); return; }\n  if (swatchMenu.contains(target)) return;\n  if (!root.contains(target) || event.button !== 2) hideSwatchMenu();\n};\nconst documentKeydownHandler = (event) =\u003e { if (event.key === \"Escape\") hideSwatchMenu(); };\nconst documentScrollHandler = () =\u003e { hideSwatchMenu(); };\ndocument.addEventListener(\"pointerdown\", documentPointerDownHandler);\ndocument.addEventListener(\"keydown\", documentKeydownHandler);\ndocument.addEventListener(\"scroll\", documentScrollHandler, true);\n\n/* ========= 初期化 ========= */\nconst bootstrap = async () =\u003e {\n  const restored = loadStoredPalette();\n  let restoredCount = 0;\n  if (restored.length) {\n    const { added } = applyColors(restored, { replace: true, persist: false });\n    restoredCount = added;\n    if (added) setStatus(`${added} 色を復元しました。`, \"info\");\n  }\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const fallback = restoredCount ? \"\" : \"#FF0000\";\n    const source = !isEmptyValue(colorInput) ? colorInput : fallback;\n    if (!source) {\n      if (!restoredCount) setStatus(\"Color ポートに色を指定してください。\", \"info\");\n      return;\n    }\n    const { added, total } = addColorsFromInput(source, { replace: restoredCount === 0 });\n    if (added) {\n      setStatus(restoredCount ? `${added} 色を追加しました。` : `${added} 色をロードしました。`,\n                restoredCount ? \"success\" : \"info\");\n    } else if (total) {\n      setStatus(restoredCount ? \"既存のパレットと同じ色のみが検出されました。\" : \"すべて既に追加済みの色です。\", \"info\");\n    }\n  } catch (error) {\n    clearSwatches({ persist: true });\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n};\n\n/* ========= +ボタン ========= */\naddBtn.addEventListener(\"click\", async () =\u003e {\n  hideSwatchMenu();\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const { added, total } = addColorsFromInput(colorInput || \"#FF0000\");\n    if (added) setStatus(`${added} 色を追加しました。`, \"success\");\n    else if (total) setStatus(\"すべて既に追加済みの色です。\", \"info\");\n  } catch (error) {\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n});\n\nbootstrap();\n\n/* ========= dispose ========= */\nreturn () =\u003e {\n  document.removeEventListener(\"pointerdown\", documentPointerDownHandler);\n  document.removeEventListener(\"keydown\", documentKeydownHandler);\n  document.removeEventListener(\"scroll\", documentScrollHandler, true);\n  hideSwatchMenu();\n  if (swatchMenu) { swatchMenu.remove(); swatchMenu = null; }\n  swatchMenuTargetKey = null;\n  swatchSet.clear();\n  paletteMap.clear();\n};\n",
               "style":  ".color-palette-node {\n  font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Noto Sans JP\", Arial, sans-serif;\n  display: grid;\n  gap: 8px;\n  position: relative;\n}\n\n.palette-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.palette-title {\n  font-weight: 600;\n}\n\n.palette-status[data-state=\"error\"] { color: #b00020; }\n.palette-status[data-state=\"success\"] { color: #137333; }\n.palette-status[data-state=\"pending\"] { color: #1a73e8; }\n.palette-status[data-state=\"info\"] { color: #5f6368; }\n\n.palette-frame {\n  border: 1px solid #e0e3e7;\n  border-radius: 12px; /* 角R */\n  padding: 10px;\n  background: #fff;\n}\n\n.palette-grid {\n  display: grid;\n  grid-template-columns: repeat(6, 56px); /* 6列 */\n  gap: 8px;\n  align-items: start;\n}\n\n.palette-add {\n  width: 56px;\n  height: 56px;\n  border: 1px dashed #9aa0a6;\n  border-radius: 12px;\n  background: #f8f9fa;\n  cursor: pointer;\n  display: inline-grid;\n  place-items: center;\n}\n\n.palette-add:hover { background: #f1f3f4; }\n.plus-icon { font-size: 20px; line-height: 1; }\n\n.palette-swatch {\n  width: 56px;\n  height: 56px;\n  border: 1px solid #dadce0;\n  border-radius: 12px;\n  background: #fff;\n  padding: 0;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n.palette-swatch svg {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n\n.palette-swatch-menu {\n  position: absolute;\n  min-width: 140px;\n  padding: 4px 0;\n  background: #ffffff;\n  border: 1px solid #dadce0;\n  border-radius: 10px;\n  box-shadow: 0 12px 32px rgba(15, 23, 42, 0.18);\n  z-index: 30;\n  font-family: inherit;\n}\n\n.palette-swatch-menu.is-hidden {\n  display: none;\n}\n\n.palette-swatch-menu__item {\n  width: 100%;\n  border: none;\n  background: transparent;\n  padding: 8px 14px;\n  text-align: left;\n  font-size: 0.9rem;\n  cursor: pointer;\n  color: inherit;\n  line-height: 1.4;\n  transition: background 120ms ease;\n}\n\n.palette-swatch-menu__item:hover,\n.palette-swatch-menu__item:focus-visible {\n  background: rgba(99, 102, 241, 0.12);\n  outline: none;\n}\n"
           },
    "description":  "",
    "createdAt":  "2025-11-04T04:00:35.843Z",
    "updatedAt":  "2025-11-04T06:57:33.554Z"
}