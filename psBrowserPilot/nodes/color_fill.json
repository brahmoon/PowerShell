{
<<<<<<< Updated upstream
  "id": "color_fill",
  "label": "Color Fill",
  "category": "Custom",
  "execution": "ui",
  "inputs": [
    "Color",
    "Sheet",
    "Range"
  ],
  "outputs": [],
  "constants": [
    {
      "key": "note",
      "type": "TextBox",
      "value": "# TODO: describe behavior"
    }
  ],
  "script": "# Use {{input.Name}} to reference incoming values,\n# {{config.key}} for constant fields, and {{output.Result}} for outputs.\n# Remove these lines and write your PowerShell snippet here.",
  "ui": {
    "markup": "<div class=\"excel-ui-node color-palette-node\" data-role=\"root\">\n  <div class=\"palette-header\">\n    <div class=\"palette-title\">Color Palette</div>\n    <div class=\"palette-status\" data-role=\"status\"></div>\n  </div>\n\n  <div class=\"palette-frame\">\n    <div class=\"palette-grid\" data-role=\"grid\">\n      <!-- SVGボタンたちがここに挿入される（+ボタンの左に追加） -->\n      <button type=\"button\" class=\"palette-add\" data-role=\"add\" aria-label=\"Add color\">\n        <span class=\"plus-icon\">＋</span>\n      </button>\n    </div>\n  </div>\n</div>\n",
    "script": "const { node, controls, updateConfig, resolveInput, ensureAutoNodes, toPowerShellLiteral } = context;\nif (!controls) return;\n\nconst grid = controls.querySelector('[data-role=\"grid\"]');\nconst addBtn = controls.querySelector('[data-role=\"add\"]');\nconst status = controls.querySelector('[data-role=\"status\"]');\n\nif (!grid || !addBtn || !status) {\n  console.warn('[color_fill] Required UI elements are missing.');\n  return;\n}\n\nconst DEFAULT_SERVER_URL = \"http://127.0.0.1:8787\";\nconst RUN_SCRIPT_PATH = \"/runScript\";\n\nconst swatchSet = new Set();\nconst paletteMap = new Map();\nconst PALETTE_CONFIG_KEY = \"colorPalette\";\nlet swatchMenu = null;\nlet swatchMenuTargetKey = null;\nconst root = controls.querySelector('[data-role=\"root\"]') || controls;\n\nconst ensureSwatchMenu = () => {\n  if (swatchMenu) {\n    return swatchMenu;\n  }\n  if (!root) {\n    return null;\n  }\n  const menu = document.createElement(\"div\");\n  menu.className = \"palette-swatch-menu is-hidden\";\n  menu.tabIndex = -1;\n  menu.addEventListener(\"contextmenu\", (event) => event.preventDefault());\n  menu.addEventListener(\"pointerdown\", (event) => event.stopPropagation());\n  const deleteBtn = document.createElement(\"button\");\n  deleteBtn.type = \"button\";\n  deleteBtn.className = \"palette-swatch-menu__item\";\n  deleteBtn.textContent = \"削除\";\n  deleteBtn.addEventListener(\"click\", () => {\n    if (!swatchMenuTargetKey) {\n      return;\n    }\n    const removed = removeSwatchByKey(swatchMenuTargetKey);\n    hideSwatchMenu();\n    if (removed) {\n      setStatus(`${removed.hex} を削除しました。`, \"info\");\n    }\n  });\n  menu.appendChild(deleteBtn);\n  root.appendChild(menu);\n  swatchMenu = menu;\n  return menu;\n};\n\nconst hideSwatchMenu = () => {\n  if (!swatchMenu) {\n    return;\n  }\n  if (!swatchMenu.classList.contains(\"is-hidden\")) {\n    swatchMenu.classList.add(\"is-hidden\");\n  }\n  swatchMenuTargetKey = null;\n};\n\nconst persistPalette = ({ silent = false } = {}) => {\n  const payload = Array.from(paletteMap.values()).filter((item) => {\n    const hex = typeof item?.hex === \"string\" ? item.hex.trim() : \"\";\n    const hasOle = item?.ole !== undefined && item?.ole !== null;\n    return hex && hasOle;\n  });\n  const serialized = payload.length ? JSON.stringify(payload) : \"\";\n  updateConfig(PALETTE_CONFIG_KEY, serialized, { silent });\n};\n\nconst clearSwatches = ({ persist = false, silent = false } = {}) => {\n  grid.querySelectorAll('.palette-swatch').forEach((node) => node.remove());\n  swatchSet.clear();\n  paletteMap.clear();\n  hideSwatchMenu();\n  if (persist) {\n    persistPalette({ silent });\n  }\n};\n\nconst removeSwatchByKey = (key) => {\n  if (key === undefined || key === null) {\n    return null;\n  }\n  const stringKey = String(key);\n  const entry = paletteMap.get(stringKey);\n  if (!entry) {\n    return null;\n  }\n  const swatch = grid.querySelector(`.palette-swatch[data-key=\"${stringKey}\"]`);\n  if (swatch) {\n    swatch.remove();\n  }\n  swatchSet.delete(stringKey);\n  paletteMap.delete(stringKey);\n  persistPalette();\n  return entry;\n};\n\nconst openSwatchMenu = (event, key) => {\n  event.preventDefault();\n  event.stopPropagation();\n  const menu = ensureSwatchMenu();\n  if (!menu || !root) {\n    return;\n  }\n  swatchMenuTargetKey = key;\n  menu.classList.remove(\"is-hidden\");\n  menu.style.left = \"0px\";\n  menu.style.top = \"0px\";\n  const rootRect = root.getBoundingClientRect();\n  const menuRect = menu.getBoundingClientRect();\n  let left = event.clientX - rootRect.left;\n  let top = event.clientY - rootRect.top;\n  if (Number.isFinite(menuRect.width) && Number.isFinite(rootRect.width)) {\n    const maxLeft = Math.max(0, rootRect.width - menuRect.width - 4);\n    left = Math.max(4, Math.min(left, maxLeft));\n  }\n  if (Number.isFinite(menuRect.height) && Number.isFinite(rootRect.height)) {\n    const maxTop = Math.max(0, rootRect.height - menuRect.height - 4);\n    top = Math.max(4, Math.min(top, maxTop));\n  }\n  menu.style.left = `${left}px`;\n  menu.style.top = `${top}px`;\n  menu.focus({ preventScroll: true });\n};\n\nconst createSwatchButton = (hex, ole) => {\n  const key = String(ole);\n  const btn = document.createElement(\"button\");\n  btn.type = \"button\";\n  btn.className = \"palette-swatch\";\n  btn.dataset.hex = hex;\n  btn.dataset.ole = String(ole);\n  btn.dataset.key = key;\n  btn.setAttribute(\"aria-label\", `${hex} を適用`);\n  btn.setAttribute(\"title\", hex);\n  btn.innerHTML = SVG_TEMPLATE.replace(/fill:#f00/gi, `fill:${hex}`);\n\n  btn.addEventListener(\"click\", async () => {\n    hideSwatchMenu();\n    btn.disabled = true;\n    try {\n      setStatus(`${hex} を適用中…`, \"pending\");\n      const rangeValue = await getPortValue(\"Range\");\n      const sheetInput = await getPortValue(\"Sheet\");\n      const rangeInfo = parseRangeInfo(rangeValue);\n      const sheetInfo = parseSheetPort(sheetInput);\n      if (sheetInfo.sheet && !rangeInfo.sheet) {\n        rangeInfo.sheet = sheetInfo.sheet;\n      }\n      if (sheetInfo.workbook && !rangeInfo.workbook) {\n        rangeInfo.workbook = sheetInfo.workbook;\n      }\n      const rangeSpec = {\n        addressLiteral: rangeInfo.address ? toPowerShellLiteral(rangeInfo.address) : null,\n        workbookLiteral: rangeInfo.workbook ? toPowerShellLiteral(rangeInfo.workbook) : null,\n        sheetLiteral: rangeInfo.sheet ? toPowerShellLiteral(rangeInfo.sheet) : null,\n      };\n      const script = buildColorApplyScript(rangeSpec, ole);\n      const data = await requestExcelJson(script);\n      if (!data?.ok) {\n        throw new Error(data?.error || \"PowerShell 実行に失敗しました。\");\n      }\n      const labelParts = [data.workbook, data.sheet, data.address].filter(Boolean);\n      const label = labelParts.length ? labelParts.join(\" \") : \"選択範囲\";\n      setStatus(`${label} に色を適用しました。`, \"success\");\n    } catch (error) {\n      setStatus(`着色に失敗: ${error.message}`, \"error\");\n    } finally {\n      btn.disabled = false;\n    }\n  });\n\n  btn.addEventListener(\"contextmenu\", (event) => {\n    openSwatchMenu(event, key);\n  });\n\n  return btn;\n};\n\nconst applyColors = (colors, { replace = false, persist = true, silentPersist = false } = {}) => {\n  const list = Array.isArray(colors) ? colors : [];\n  if (replace) {\n    clearSwatches({ persist: false });\n  }\n  let added = 0;\n  for (const item of list) {\n    if (!item) {\n      continue;\n    }\n    const hex = typeof item.hex === \"string\" ? item.hex.trim() : \"\";\n    const ole = item.ole;\n    const hasOle = ole !== undefined && ole !== null;\n    if (!hex || !hasOle) {\n      continue;\n    }\n    const key = String(ole);\n    if (swatchSet.has(key)) {\n      continue;\n    }\n    const swatch = createSwatchButton(hex, ole);\n    grid.insertBefore(swatch, addBtn);\n    swatchSet.add(key);\n    paletteMap.set(key, { hex, ole });\n    added += 1;\n  }\n  if (persist && (replace || added)) {\n    persistPalette({ silent: silentPersist });\n  }\n  return { added, total: list.length };\n};\n\nconst addColorsFromInput = (rawValue, { replace = false, persist = true, silentPersist = false } = {}) => {\n  if (isEmptyValue(rawValue)) {\n    if (replace) {\n      clearSwatches({ persist, silent: silentPersist });\n    }\n    return { added: 0, total: 0 };\n  }\n  const colors = parseColors(rawValue);\n  return applyColors(colors, { replace, persist, silentPersist });\n};\n\nconst loadStoredPalette = () => {\n  const raw = node?.config?.[PALETTE_CONFIG_KEY];\n  if (typeof raw !== \"string\") {\n    return [];\n  }\n  const trimmed = raw.trim();\n  if (!trimmed) {\n    return [];\n  }\n  try {\n    const parsed = JSON.parse(trimmed);\n    if (!Array.isArray(parsed)) {\n      return [];\n    }\n    return parsed\n      .map((item) => {\n        if (!item) {\n          return null;\n        }\n        const hex = typeof item.hex === \"string\" ? item.hex.trim() : \"\";\n        const ole = item.ole;\n        const hasOle = ole !== undefined && ole !== null;\n        if (!hex || !hasOle) {\n          return null;\n        }\n        return { hex, ole };\n      })\n      .filter(Boolean);\n  } catch (error) {\n    console.warn('[color_fill] Failed to parse stored palette', error);\n    return [];\n  }\n};\n\nconst documentPointerDownHandler = (event) => {\n  if (!swatchMenu || swatchMenu.classList.contains(\"is-hidden\")) {\n    return;\n  }\n  const target = event.target;\n  if (!target || !(target instanceof Node)) {\n    hideSwatchMenu();\n    return;\n  }\n  if (swatchMenu.contains(target)) {\n    return;\n  }\n  if (!root.contains(target) || event.button !== 2) {\n    hideSwatchMenu();\n  }\n};\n\nconst documentKeydownHandler = (event) => {\n  if (event.key === \"Escape\") {\n    hideSwatchMenu();\n  }\n};\n\nconst documentScrollHandler = () => {\n  hideSwatchMenu();\n};\n\ndocument.addEventListener(\"pointerdown\", documentPointerDownHandler);\ndocument.addEventListener(\"keydown\", documentKeydownHandler);\ndocument.addEventListener(\"scroll\", documentScrollHandler, true);\n/* ====== 初期化 ====== */\nconst bootstrap = async () => {\n  const restored = loadStoredPalette();\n  let restoredCount = 0;\n  if (restored.length) {\n    const { added } = applyColors(restored, { replace: true, persist: false });\n    restoredCount = added;\n    if (added) {\n      setStatus(`${added} 色を復元しました。`, \"info\");\n    }\n  }\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const fallback = restoredCount ? \"\" : \"#FF0000\";\n    const source = !isEmptyValue(colorInput) ? colorInput : fallback;\n    if (!source) {\n      if (!restoredCount) {\n        setStatus(\"Color ポートに色を指定してください。\", \"info\");\n      }\n      return;\n    }\n    const { added, total } = addColorsFromInput(source, {\n      replace: restoredCount === 0,\n    });\n    if (added) {\n      setStatus(\n        restoredCount ? `${added} 色を追加しました。` : `${added} 色をロードしました。`,\n        restoredCount ? \"success\" : \"info\"\n      );\n    } else if (total) {\n      if (restoredCount) {\n        setStatus(\"既存のパレットと同じ色のみが検出されました。\", \"info\");\n      } else {\n        setStatus(\"すべて既に追加済みの色です。\", \"info\");\n      }\n    }\n  } catch (error) {\n    clearSwatches({ persist: true });\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n};\n\n/* ====== +ボタン押下 ====== */\naddBtn.addEventListener(\"click\", async () => {\n  hideSwatchMenu();\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const { added, total } = addColorsFromInput(colorInput || \"#FF0000\");\n    if (added) {\n      setStatus(`${added} 色を追加しました。`, \"success\");\n    } else if (total) {\n      setStatus(\"すべて既に追加済みの色です。\", \"info\");\n    }\n  } catch (error) {\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n});\n\nbootstrap();\n\nreturn () => {\n  document.removeEventListener(\"pointerdown\", documentPointerDownHandler);\n  document.removeEventListener(\"keydown\", documentKeydownHandler);\n  document.removeEventListener(\"scroll\", documentScrollHandler, true);\n  hideSwatchMenu();\n  if (swatchMenu) {\n    swatchMenu.remove();\n    swatchMenu = null;\n  }\n  swatchMenuTargetKey = null;\n  swatchSet.clear();\n  paletteMap.clear();\n};\n",
    "style": ".color-palette-node {\n  font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Noto Sans JP\", Arial, sans-serif;\n  display: grid;\n  gap: 8px;\n  position: relative;\n}\n\n.palette-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.palette-title {\n  font-weight: 600;\n}\n\n.palette-status[data-state=\"error\"] { color: #b00020; }\n.palette-status[data-state=\"success\"] { color: #137333; }\n.palette-status[data-state=\"pending\"] { color: #1a73e8; }\n.palette-status[data-state=\"info\"] { color: #5f6368; }\n\n.palette-frame {\n  border: 1px solid #e0e3e7;\n  border-radius: 12px; /* 角R */\n  padding: 10px;\n  background: #fff;\n}\n\n.palette-grid {\n  display: grid;\n  grid-template-columns: repeat(6, 56px); /* 6列 */\n  gap: 8px;\n  align-items: start;\n}\n\n.palette-add {\n  width: 56px;\n  height: 56px;\n  border: 1px dashed #9aa0a6;\n  border-radius: 12px;\n  background: #f8f9fa;\n  cursor: pointer;\n  display: inline-grid;\n  place-items: center;\n}\n\n.palette-add:hover { background: #f1f3f4; }\n.plus-icon { font-size: 20px; line-height: 1; }\n\n.palette-swatch {\n  width: 56px;\n  height: 56px;\n  border: 1px solid #dadce0;\n  border-radius: 12px;\n  background: #fff;\n  padding: 0;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n.palette-swatch svg {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n\n.palette-swatch-menu {\n  position: absolute;\n  min-width: 140px;\n  padding: 4px 0;\n  background: #ffffff;\n  border: 1px solid #dadce0;\n  border-radius: 10px;\n  box-shadow: 0 12px 32px rgba(15, 23, 42, 0.18);\n  z-index: 30;\n  font-family: inherit;\n}\n\n.palette-swatch-menu.is-hidden {\n  display: none;\n}\n\n.palette-swatch-menu__item {\n  width: 100%;\n  border: none;\n  background: transparent;\n  padding: 8px 14px;\n  text-align: left;\n  font-size: 0.9rem;\n  cursor: pointer;\n  color: inherit;\n  line-height: 1.4;\n  transition: background 120ms ease;\n}\n\n.palette-swatch-menu__item:hover,\n.palette-swatch-menu__item:focus-visible {\n  background: rgba(99, 102, 241, 0.12);\n  outline: none;\n}\n"
  },
  "description": "",
  "createdAt": "2025-11-04T04:00:35.843Z",
  "updatedAt": "2025-11-04T05:36:01.720Z"
=======
    "id":  "color_fill",
    "label":  "Color Fill",
    "category":  "Custom",
    "execution":  "ui",
    "inputs":  [
                   "Color",
                   "Sheet",
                   "Range"
               ],
    "outputs":  [

                ],
    "constants":  [
                      {
                          "key":  "note",
                          "type":  "TextBox",
                          "value":  "# TODO: describe behavior"
                      }
                  ],
    "script":  "# Use {{input.Name}} to reference incoming values,\n# {{config.key}} for constant fields, and {{output.Result}} for outputs.\n# Remove these lines and write your PowerShell snippet here.",
    "ui":  {
               "markup":  "\u003cdiv class=\"excel-ui-node color-palette-node\" data-role=\"root\"\u003e\n  \u003cdiv class=\"palette-header\"\u003e\n    \u003cdiv class=\"palette-title\"\u003eColor Palette\u003c/div\u003e\n    \u003cdiv class=\"palette-status\" data-role=\"status\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n\n  \u003cdiv class=\"palette-frame\"\u003e\n    \u003cdiv class=\"palette-grid\" data-role=\"grid\"\u003e\n      \u003c!-- SVGボタンたちがここに挿入される（+ボタンの左に追加） --\u003e\n      \u003cbutton type=\"button\" class=\"palette-add\" data-role=\"add\" aria-label=\"Add color\"\u003e\n        \u003cspan class=\"plus-icon\"\u003e＋\u003c/span\u003e\n      \u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n",
               "script":  "const { node, controls, updateConfig, resolveInput, ensureAutoNodes, toPowerShellLiteral } = context;\nif (!controls) return;\n\nconst grid = controls.querySelector(\u0027[data-role=\"grid\"]\u0027);\nconst addBtn = controls.querySelector(\u0027[data-role=\"add\"]\u0027);\nconst status = controls.querySelector(\u0027[data-role=\"status\"]\u0027);\n\nif (!grid || !addBtn || !status) {\n  console.warn(\u0027[color_fill] Required UI elements are missing.\u0027);\n  return;\n}\n\nconst DEFAULT_SERVER_URL = \"http://127.0.0.1:8787\";\nconst RUN_SCRIPT_PATH = \"/runScript\";\nconst swatchSet = new Set();\n\n/* ====== サーバ通信共通関数 ====== */\nconst normalizeServerUrl = (value) =\u003e {\n  if (value === undefined || value === null) return \"\";\n  let url = String(value).trim();\n  if (!url) return \"\";\n  if (!/^https?:\\/\\//i.test(url)) {\n    url = `http://${url}`;\n  }\n  return url.replace(/\\/+$/, \"\");\n};\n\nconst loadServerUrl = () =\u003e {\n  try {\n    const stored = window?.localStorage?.getItem(\"nodeflow.psServerUrl\");\n    if (stored) {\n      const normalized = normalizeServerUrl(stored);\n      return normalized || DEFAULT_SERVER_URL;\n    }\n  } catch (error) {\n    console.warn(\"Failed to read stored PowerShell server URL\", error);\n  }\n  return DEFAULT_SERVER_URL;\n};\n\nconst getRunScriptEndpoint = () =\u003e {\n  const base = normalizeServerUrl(loadServerUrl()) || DEFAULT_SERVER_URL;\n  return `${base}${RUN_SCRIPT_PATH}`;\n};\n\nconst invokePowerShell = async (script) =\u003e {\n  const endpoint = getRunScriptEndpoint();\n  const response = await fetch(endpoint, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json; charset=utf-8\" },\n    body: JSON.stringify({ script }),\n  });\n\n  let payload;\n  try {\n    payload = await response.json();\n  } catch {\n    throw new Error(\"PowerShell サーバーから無効な応答を受信しました。\");\n  }\n\n  if (!response.ok) {\n    throw new Error(payload?.error || `HTTP ${response.status}`);\n  }\n  if (payload?.ok === false) {\n    const message = Array.isArray(payload?.errors) \u0026\u0026 payload.errors.length\n      ? payload.errors.join(\"\\n\")\n      : payload?.error || \"PowerShell がエラーを返しました。\";\n    throw new Error(message);\n  }\n\n  return typeof payload?.output === \"string\" ? payload.output.trim() : \"\";\n};\n\nconst requestExcelJson = async (script) =\u003e {\n  const output = await invokePowerShell(script);\n  if (!output) return null;\n  try {\n    return JSON.parse(output);\n  } catch {\n    throw new Error(\"PowerShell の応答を解析できませんでした。\");\n  }\n};\n\n/* ====== 共通UI関数 ====== */\nconst setStatus = (message, state = \"\") =\u003e {\n  status.textContent = message || \"\";\n  status.dataset.state = state;\n};\n\nconst isEmptyValue = (value) =\u003e\n  value === undefined ||\n  value === null ||\n  (typeof value === \"string\" \u0026\u0026 !value.trim());\n\n/* ====== 値解析ユーティリティ ====== */\nconst tryParseStructured = (value) =\u003e {\n  if (typeof value !== \"string\") return value;\n  const trimmed = value.trim();\n  if (!trimmed) return \"\";\n  if (\n    (trimmed.startsWith(\"{\") \u0026\u0026 trimmed.endsWith(\"}\")) ||\n    (trimmed.startsWith(\"[\") \u0026\u0026 trimmed.endsWith(\"]\")) ||\n    /^(true|false|null)$/i.test(trimmed)\n  ) {\n    try {\n      return JSON.parse(trimmed);\n    } catch {\n      // fall through\n    }\n  }\n  return value;\n};\n\nconst isPlainObject = (value) =\u003e\n  Object.prototype.toString.call(value) === \"[object Object]\";\n\nconst getPortValue = async (name) =\u003e {\n  const targets = Array.isArray(name) ? name.filter(Boolean) : [name].filter(Boolean);\n  if (typeof ensureAutoNodes === \"function\" \u0026\u0026 targets.length) {\n    try {\n      await ensureAutoNodes(targets);\n    } catch (error) {\n      console.warn(`[color_fill] Failed to auto-update input ${targets.join(\", \")}`, error);;\n      throw error;\n    }\n  }\n\n  if (typeof resolveInput === \"function\") {\n    try {\n      const raw = resolveInput(name, { preferRaw: true });\n      if (!isEmptyValue(raw)) return raw;\n      const resolved = resolveInput(name);\n      if (!isEmptyValue(resolved)) return resolved;\n    } catch (error) {\n      console.warn(`[color_fill] Failed to resolve input ${name}`, error);\n    }\n  }\n\n  const rawConfig = node?.config?.[`${name}__raw`];\n  if (!isEmptyValue(rawConfig)) return rawConfig;\n\n  const stored = node?.config?.[name];\n  if (!isEmptyValue(stored)) return stored;\n\n  return \"\";\n};\n\n/* ====== 色ユーティリティ ====== */\nconst clampChannel = (value) =\u003e {\n  const num = Number(value);\n  if (!Number.isFinite(num)) {\n    throw new Error(\"RGB の値が数値ではありません。\");\n  }\n  return Math.max(0, Math.min(255, Math.round(num)));\n};\n\nconst rgbToHex = (r, g, b) =\u003e\n  \"#\" + [r, g, b].map((v) =\u003e v.toString(16).padStart(2, \"0\")).join(\"\").toUpperCase();\n\nconst rgbToOle = (r, g, b) =\u003e r + g * 256 + b * 65536;\n\nconst hexToRgb = (hex) =\u003e {\n  const value = hex.replace(\"#\", \"\");\n  const full = value.length === 3 ? value.split(\"\").map((c) =\u003e c + c).join(\"\") : value;\n  const int = parseInt(full, 16);\n  return {\n    r: (int \u003e\u003e 16) \u0026 255,\n    g: (int \u003e\u003e 8) \u0026 255,\n    b: int \u0026 255,\n  };\n};\n\nconst oleToColor = (oleValue) =\u003e {\n  const numeric = Number(oleValue);\n  if (!Number.isFinite(numeric)) {\n    throw new Error(\"OLE 色の値が不正です。\");\n  }\n  const ole = numeric \u003e\u003e\u003e 0;\n  const r = ole \u0026 255;\n  const g = (ole \u003e\u003e\u003e 8) \u0026 255;\n  const b = (ole \u003e\u003e\u003e 16) \u0026 255;\n  return { hex: rgbToHex(r, g, b), ole };\n};\n\nconst tupleToColor = (tuple) =\u003e {\n  if (!Array.isArray(tuple) || tuple.length !== 3) {\n    throw new Error(\"RGB の配列は 3 要素で指定してください。\");\n  }\n  const [r, g, b] = tuple.map(clampChannel);\n  return { hex: rgbToHex(r, g, b), ole: rgbToOle(r, g, b) };\n};\n\nconst colorFromHexString = (value) =\u003e {\n  if (typeof value !== \"string\") {\n    throw new Error(\"HEX の形式が不正です。\");\n  }\n  let hex = value.trim();\n  if (!hex) {\n    throw new Error(\"HEX の形式が不正です。\");\n  }\n  if (/^0x[0-9a-f]+$/i.test(hex)) {\n    hex = `#${hex.slice(2)}`;\n  } else if (!hex.startsWith(\"#\")) {\n    hex = `#${hex}`;\n  }\n  if (!/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(hex)) {\n    throw new Error(\"HEX の形式が不正です。\");\n  }\n  const { r, g, b } = hexToRgb(hex);\n  return { hex: rgbToHex(r, g, b), ole: rgbToOle(r, g, b) };\n};\n\nconst flattenColorInput = (input) =\u003e {\n  const value = tryParseStructured(input);\n  if (value === undefined || value === null || value === \"\") {\n    return [];\n  }\n\n  if (typeof value === \"number\" \u0026\u0026 Number.isFinite(value)) {\n    return [oleToColor(value)];\n  }\n\n  if (typeof value === \"string\") {\n    const str = value.trim();\n    if (!str) return [];\n\n    if (/^#/.test(str) || /^0x[0-9a-f]+$/i.test(str) || /^[0-9a-f]{3,6}$/i.test(str)) {\n      try {\n        return [colorFromHexString(str)];\n      } catch {\n        return [];\n      }\n    }\n\n    const rgbMatch = str.match(/^rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/i);\n    if (rgbMatch) {\n      return [tupleToColor([rgbMatch[1], rgbMatch[2], rgbMatch[3]])];\n    }\n\n    const parts = str.split(/[\\s,;]+/).filter(Boolean);\n    if (parts.length === 3 \u0026\u0026 parts.every((p) =\u003e /^-?\\d+(?:\\.\\d+)?$/.test(p))) {\n      try {\n        return [tupleToColor(parts)];\n      } catch {\n        return [];\n      }\n    }\n\n    if (parts.length \u003e 1 \u0026\u0026 parts.every((p) =\u003e /^#?[0-9a-f]{3,6}$/i.test(p))) {\n      return parts.flatMap((p) =\u003e flattenColorInput(p));\n    }\n\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    if (value.length === 3 \u0026\u0026 value.every((v) =\u003e Number.isFinite(Number(v)))) {\n      return [tupleToColor(value)];\n    }\n    return value.flatMap((item) =\u003e flattenColorInput(item));\n  }\n\n  if (isPlainObject(value)) {\n    const results = [];\n    const directKeys = [\n      \"hex\",\n      \"Hex\",\n      \"color\",\n      \"Color\",\n      \"colour\",\n      \"Colour\",\n      \"value\",\n      \"Value\",\n    ];\n    for (const key of directKeys) {\n      if (key in value) {\n        results.push(...flattenColorInput(value[key]));\n      }\n    }\n    if (\"ole\" in value) {\n      results.push(...flattenColorInput(value.ole));\n    }\n    if (\"rgb\" in value) {\n      results.push(...flattenColorInput(value.rgb));\n    }\n    if (\"RGB\" in value) {\n      results.push(...flattenColorInput(value.RGB));\n    }\n    if ([\"r\", \"g\", \"b\"].every((k) =\u003e k in value)) {\n      results.push(tupleToColor([value.r, value.g, value.b]));\n    }\n    const nestedKeys = [\"colors\", \"Colours\", \"swatches\", \"items\", \"data\", \"list\"];\n    for (const key of nestedKeys) {\n      if (key in value) {\n        results.push(...flattenColorInput(value[key]));\n      }\n    }\n    return results;\n  }\n\n  return [];\n};\n\nconst parseColors = (value) =\u003e {\n  const colors = flattenColorInput(value);\n  if (!colors.length) {\n    throw new Error(\"Color の解釈に失敗しました（HEX または RGB を指定してください）。\");\n  }\n  const seen = new Set();\n  return colors.filter((color) =\u003e {\n    const key = String(color.ole);\n    if (!key || seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n};\n\n/* ====== Range 情報解析 ====== */\nconst parseRangeInfo = (value) =\u003e {\n  const info = { address: \"\", workbook: \"\", sheet: \"\" };\n  const visited = new Set();\n\n  const assignString = (key, candidate) =\u003e {\n    if (info[key]) return;\n    if (typeof candidate === \"string\") {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        info[key] = trimmed;\n      }\n    }\n  };\n\n  const inspect = (input) =\u003e {\n    const parsed = tryParseStructured(input);\n    if (parsed === undefined || parsed === null || parsed === \"\") {\n      return;\n    }\n\n    if (typeof parsed === \"string\") {\n      const trimmed = parsed.trim();\n      if (trimmed \u0026\u0026 !info.address) {\n        info.address = trimmed;\n      }\n      return;\n    }\n\n    if (typeof parsed === \"number\" || typeof parsed === \"boolean\") {\n      return;\n    }\n\n    if (Array.isArray(parsed)) {\n      for (const item of parsed) {\n        if (info.address \u0026\u0026 info.workbook \u0026\u0026 info.sheet) break;\n        inspect(item);\n      }\n      return;\n    }\n\n    if (!isPlainObject(parsed) || visited.has(parsed)) {\n      return;\n    }\n    visited.add(parsed);\n\n    assignString(\"address\", parsed.SelectionAddress__raw);\n    assignString(\"address\", parsed.SelectionAddress);\n    assignString(\"address\", parsed.address);\n    assignString(\"address\", parsed.Address);\n    assignString(\"address\", parsed.range);\n    assignString(\"address\", parsed.Range);\n    assignString(\"address\", parsed.targetAddress);\n\n    assignString(\"workbook\", parsed.workbook);\n    assignString(\"workbook\", parsed.Workbook);\n    assignString(\"workbook\", parsed.workbookName);\n    assignString(\"workbook\", parsed.WorkbookName);\n    assignString(\"workbook\", parsed.book);\n\n    assignString(\"sheet\", parsed.sheet);\n    assignString(\"sheet\", parsed.Sheet);\n    assignString(\"sheet\", parsed.sheetName);\n    assignString(\"sheet\", parsed.SheetName);\n    assignString(\"sheet\", parsed.worksheet);\n    assignString(\"sheet\", parsed.Worksheet);\n\n    const nestedKeys = [\n      \"selection\",\n      \"Selection\",\n      \"target\",\n      \"Target\",\n      \"value\",\n      \"Value\",\n      \"data\",\n      \"Data\",\n      \"range\",\n      \"Range\",\n    ];\n    for (const key of nestedKeys) {\n      if (info.address \u0026\u0026 info.workbook \u0026\u0026 info.sheet) break;\n      if (key in parsed) {\n        inspect(parsed[key]);\n      }\n    }\n  };\n\n  inspect(value);\n  return info;\n};\n\n\nconst parseSheetPort = (value) =\u003e {\n  const info = { sheet: \"\", workbook: \"\" };\n  const visited = new Set();\n\n  const assignSheet = (candidate) =\u003e {\n    if (info.sheet) return;\n    if (typeof candidate === \"string\") {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        info.sheet = trimmed;\n      }\n    }\n  };\n\n  const assignWorkbook = (candidate) =\u003e {\n    if (info.workbook) return;\n    if (typeof candidate === \"string\") {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        info.workbook = trimmed;\n      }\n    }\n  };\n\n  const inspect = (input) =\u003e {\n    const parsed = tryParseStructured(input);\n    if (parsed === undefined || parsed === null || parsed === \"\") {\n      return;\n    }\n\n    if (typeof parsed === \"string\") {\n      if (!info.sheet) {\n        const trimmed = parsed.trim();\n        if (trimmed) {\n          info.sheet = trimmed;\n        }\n      }\n      return;\n    }\n\n    if (typeof parsed === \"number\" || typeof parsed === \"boolean\") {\n      return;\n    }\n\n    if (Array.isArray(parsed)) {\n      for (const item of parsed) {\n        if (info.sheet \u0026\u0026 info.workbook) break;\n        inspect(item);\n      }\n      return;\n    }\n\n    if (!isPlainObject(parsed) || visited.has(parsed)) {\n      return;\n    }\n    visited.add(parsed);\n\n    assignSheet(parsed.sheet);\n    assignSheet(parsed.Sheet);\n    assignSheet(parsed.sheetName);\n    assignSheet(parsed.SheetName);\n    assignSheet(parsed.worksheet);\n    assignSheet(parsed.Worksheet);\n\n    assignWorkbook(parsed.workbook);\n    assignWorkbook(parsed.Workbook);\n    assignWorkbook(parsed.workbookName);\n    assignWorkbook(parsed.WorkbookName);\n    assignWorkbook(parsed.book);\n    assignWorkbook(parsed.Book);\n\n    const nestedKeys = [\n      \"selection\",\n      \"Selection\",\n      \"target\",\n      \"Target\",\n      \"source\",\n      \"Source\",\n      \"context\",\n      \"Context\",\n      \"sheet\",\n      \"Sheet\",\n      \"worksheet\",\n      \"Worksheet\",\n    ];\n\n    for (const key of nestedKeys) {\n      if (info.sheet \u0026\u0026 info.workbook) break;\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        inspect(parsed[key]);\n      }\n    }\n  };\n\n  inspect(value);\n  return info;\n};\n/* ====== PowerShell スクリプト生成 ====== */\nconst COLOR_HELPERS = [\n  \"function Convert-OleToHex {\",\n  \"  param([Parameter()][object]$Ole)\",\n  \"  if ($null -eq $Ole) { return $null }\",\n  \"  try {\",\n  \"    $c = [System.Drawing.ColorTranslator]::FromOle([int]$Ole)\",\n  \"    return (\u0027#{0:X2}{1:X2}{2:X2}\u0027 -f $c.R, $c.G, $c.B)\",\n  \"  } catch { return $null }\",\n  \"}\"\n].join(\"\\n\");\n\nconst buildColorApplyScript = (rangeSpec, colorInt) =\u003e {\n  const { addressLiteral, workbookLiteral, sheetLiteral } = rangeSpec;\n  const useAddress = Boolean(addressLiteral);\n  const useWorkbook = Boolean(workbookLiteral);\n  const useSheet = Boolean(sheetLiteral);\n\n  const lines = [\n    \"$ErrorActionPreference = \u0027Stop\u0027\",\n    \"Add-Type -AssemblyName System.Drawing\",\n    COLOR_HELPERS,\n    \"$excel = $null\",\n    \"$workbook = $null\",\n    \"$sheet = $null\",\n    \"$target = $null\",\n    \"try {\",\n    \"  $excel = [Runtime.Interopservices.Marshal]::GetActiveObject(\u0027Excel.Application\u0027)\",\n    \"  if ($null -eq $excel) { throw \u0027Excel が見つかりません。\u0027 }\",\n  ];\n\n  if (useWorkbook) {\n    lines.push(\n      \"  foreach ($wb in @($excel.Workbooks)) {\",\n      `    if ($null -ne $wb -and $wb.Name -eq ${workbookLiteral}) {`,\n      \"      $workbook = $wb\",\n      \"      break\",\n      \"    }\",\n      \"  }\",\n      `  if ($null -eq $workbook) { throw (\\\"Workbook not found: {0}\\\" -f ${workbookLiteral}) }`\n    );\n  } else {\n    lines.push(\"  $workbook = $excel.ActiveWorkbook\");\n  }\n\n  lines.push(\"  if ($null -eq $workbook) { $workbook = $excel.ActiveWorkbook }\");\n\n  if (useSheet) {\n    lines.push(\n      \"  if ($workbook -ne $null) {\",\n      \"    foreach ($ws in @($workbook.Worksheets)) {\",\n      `      if ($null -ne $ws -and $ws.Name -eq ${sheetLiteral}) {`,\n      \"        $sheet = $ws\",\n      \"        break\",\n      \"      }\",\n      \"    }\",\n      \"  }\",\n      `  if ($null -eq $sheet) { throw (\\\"Worksheet not found: {0}\\\" -f ${sheetLiteral}) }`\n    );\n  } else {\n    lines.push(\"  if ($workbook -ne $null) { $sheet = $workbook.ActiveSheet }\");\n  }\n\n  lines.push(\"  if ($sheet -eq $null) { try { $sheet = $excel.ActiveSheet } catch { $sheet = $null } }\");\n\n  if (useAddress) {\n    lines.push(\n      \"  if ($sheet -ne $null) {\",\n      \"    try {\",\n      `      $target = $sheet.Range(${addressLiteral})`,\n      \"    } catch {\",\n      \"      $target = $null\",\n      \"    }\",\n      \"  }\",\n      \"  if ($target -eq $null) {\",\n      \"    try {\",\n      `      $target = $excel.Range(${addressLiteral})`,\n      \"    } catch {\",\n      \"      $target = $null\",\n      \"    }\",\n      \"  }\"\n    );\n  }\n\n  lines.push(\n    \"  if ($target -eq $null) {\",\n    \"    $target = $excel.Selection\",\n    \"  }\",\n    \"  if ($null -eq $target) { throw \u0027範囲が取得できません。\u0027 }\",\n    `  $target.Interior.Color = ${colorInt}`,\n    \"  $result = [pscustomobject]@{\",\n    \"    ok = $true;\",\n    \"    workbook = try { $workbook?.Name } catch { $null };\",\n    \"    sheet = try { $sheet?.Name } catch { $null };\",\n    \"    address = try { $target.Address() } catch { $null };\",\n    \"    interior_color = @{\",\n    \"      hex = Convert-OleToHex $target.Interior.Color;\",\n    \"      ole = $target.Interior.Color\",\n    \"    }\",\n    \"  }\",\n    \"} catch {\",\n    \"  $result = [pscustomobject]@{ ok = $false; error = $_.Exception.Message }\",\n    \"} finally {\",\n    \"  if ($target -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($target) | Out-Null }\",\n    \"  if ($sheet -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($sheet) | Out-Null }\",\n    \"  if ($workbook -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($workbook) | Out-Null }\",\n    \"  if ($excel -ne $null) { [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null }\",\n    \"  [GC]::Collect()\",\n    \"  [GC]::WaitForPendingFinalizers()\",\n    \"}\",\n    \"$result | ConvertTo-Json -Compress\"\n  );\n\n  return lines.join(\"\\n\");\n};\n\n/* ====== SVGテンプレート ====== */\nconst SVG_TEMPLATE = `\u003c?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?\u003e\u003csvg width=\"100%\" height=\"100%\" viewBox=\"0 0 480 480\" xmlns=\"http://www.w3.org/2000/svg\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;\"\u003e\u003cpath d=\"M358.299,246.425l0,73.701l22.677,0l51.024,-48.189l0,-96.378l-25.512,-25.512l-76.535,0l62.362,62.362l-34.016,34.016Z\" fill=\"#5ea3d9\"/\u003e\u003cpath d=\"M261.921,195.402l-22.677,0l0,-124.724l-56.693,0l0,102.047l-22.677,0l0,-124.724l102.047,0l0,147.402Z\" fill=\"#000\"/\u003e\u003cpath d=\"M193.89,342.803l-106.906,-113.386l163.599,-158.74l141.732,141.732l-130.394,130.394l-68.031,-0Zm22.677,-22.677l22.677,0l107.717,-107.717l-96.378,-96.378l-118.244,113.386l84.229,90.709Z\" fill=\"#000\"/\u003e\u003crect x=\"46.488\" y=\"342.803\" width=\"385.512\" height=\"90.709\" style=\"fill:#f00;\"/\u003e \u003c/svg\u003e`;\n\nconst createSwatchButton = (hex, ole) =\u003e {\n  const btn = document.createElement(\"button\");\n  btn.type = \"button\";\n  btn.className = \"palette-swatch\";\n  btn.dataset.hex = hex;\n  btn.dataset.ole = String(ole);\n  btn.setAttribute(\"aria-label\", `${hex} を適用`);\n  btn.setAttribute(\"title\", hex);\n  btn.innerHTML = SVG_TEMPLATE.replace(/fill:#f00/gi, `fill:${hex}`);\n\n  btn.addEventListener(\"click\", async () =\u003e {\n    btn.disabled = true;\n    try {\n      setStatus(`${hex} を適用中…`, \"pending\");\n      const rangeValue = await getPortValue(\"Range\");\n      const sheetInput = await getPortValue(\"Sheet\");\n      const rangeInfo = parseRangeInfo(rangeValue);\n      const sheetInfo = parseSheetPort(sheetInput);\n      if (sheetInfo.sheet \u0026\u0026 !rangeInfo.sheet) {\n        rangeInfo.sheet = sheetInfo.sheet;\n      }\n      if (sheetInfo.workbook \u0026\u0026 !rangeInfo.workbook) {\n        rangeInfo.workbook = sheetInfo.workbook;\n      }\n      const rangeSpec = {\n        addressLiteral: rangeInfo.address ? toPowerShellLiteral(rangeInfo.address) : null,\n        workbookLiteral: rangeInfo.workbook ? toPowerShellLiteral(rangeInfo.workbook) : null,\n        sheetLiteral: rangeInfo.sheet ? toPowerShellLiteral(rangeInfo.sheet) : null,\n      };\n      const script = buildColorApplyScript(rangeSpec, ole);\n      const data = await requestExcelJson(script);\n      if (!data?.ok) {\n        throw new Error(data?.error || \"PowerShell 実行に失敗しました。\");\n      }\n      const labelParts = [data.workbook, data.sheet, data.address].filter(Boolean);\n      const label = labelParts.length ? labelParts.join(\" \") : \"選択範囲\";\n      setStatus(`${label} に色を適用しました。`, \"success\");\n    } catch (error) {\n      setStatus(`着色に失敗: ${error.message}`, \"error\");\n    } finally {\n      btn.disabled = false;\n    }\n  });\n\n  return btn;\n};\n\nconst addColorsFromInput = (rawValue, { replace = false } = {}) =\u003e {\n  const colors = parseColors(rawValue);\n  if (replace) {\n    grid.querySelectorAll(\u0027.palette-swatch\u0027).forEach((node) =\u003e node.remove());\n    swatchSet.clear();\n  }\n  let added = 0;\n  for (const color of colors) {\n    const key = String(color.ole);\n    if (swatchSet.has(key)) continue;\n    const swatch = createSwatchButton(color.hex, color.ole);\n    grid.insertBefore(swatch, addBtn);\n    swatchSet.add(key);\n    added += 1;\n  }\n  return { added, total: colors.length };\n};\n\n/* ====== 初期化 ====== */\nconst bootstrap = async () =\u003e {\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const { added, total } = addColorsFromInput(colorInput || \"#FF0000\", { replace: true });\n    if (added) {\n      setStatus(`${added} 色をロードしました。`, \"info\");\n    } else if (total) {\n      setStatus(\"すべて既に追加済みの色です。\", \"info\");\n    }\n  } catch (error) {\n    grid.querySelectorAll(\u0027.palette-swatch\u0027).forEach((node) =\u003e node.remove());\n    swatchSet.clear();\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n};\n\n/* ====== +ボタン押下 ====== */\naddBtn.addEventListener(\"click\", async () =\u003e {\n  try {\n    const colorInput = await getPortValue(\"Color\");\n    const { added, total } = addColorsFromInput(colorInput || \"#FF0000\");\n    if (added) {\n      setStatus(`${added} 色を追加しました。`, \"success\");\n    } else if (total) {\n      setStatus(\"すべて既に追加済みの色です。\", \"info\");\n    }\n  } catch (error) {\n    setStatus(`Color の解釈に失敗: ${error.message}`, \"error\");\n  }\n});\n\nbootstrap();\n",
               "style":  ".color-palette-node {\n  font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Noto Sans JP\", Arial, sans-serif;\n  display: grid;\n  gap: 8px;\n}\n\n.palette-header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.palette-title {\n  font-weight: 600;\n}\n\n.palette-status[data-state=\"error\"] { color: #b00020; }\n.palette-status[data-state=\"success\"] { color: #137333; }\n.palette-status[data-state=\"pending\"] { color: #1a73e8; }\n.palette-status[data-state=\"info\"] { color: #5f6368; }\n\n.palette-frame {\n  border: 1px solid #e0e3e7;\n  border-radius: 12px; /* 角R */\n  padding: 10px;\n  background: #fff;\n}\n\n.palette-grid {\n  display: grid;\n  grid-template-columns: repeat(6, 56px); /* 6列 */\n  gap: 8px;\n  align-items: start;\n}\n\n.palette-add {\n  width: 56px;\n  height: 56px;\n  border: 1px dashed #9aa0a6;\n  border-radius: 12px;\n  background: #f8f9fa;\n  cursor: pointer;\n  display: inline-grid;\n  place-items: center;\n}\n\n.palette-add:hover { background: #f1f3f4; }\n.plus-icon { font-size: 20px; line-height: 1; }\n\n.palette-swatch {\n  width: 56px;\n  height: 56px;\n  border: 1px solid #dadce0;\n  border-radius: 12px;\n  background: #fff;\n  padding: 0;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n.palette-swatch svg {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n"
           },
    "description":  "",
    "createdAt":  "2025-11-04T04:00:35.843Z",
    "updatedAt":  "2025-11-04T06:00:10.118Z"
>>>>>>> Stashed changes
}