<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>psBrowserPilot - NodeFlow PowerShell Orchestrator</title>
    <link rel="stylesheet" href="../NodeFlow/ui/editor.css" />
    <style>
      .session-bar {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .session-bar select {
        min-width: 200px;
      }
      .session-status {
        font-size: 12px;
        color: var(--muted, #6b7280);
      }
      .log-panel {
        max-height: 220px;
        overflow: auto;
        padding: 16px;
        border-top: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.04);
        font-family: "Cascadia Code", "Fira Code", monospace;
        font-size: 13px;
        line-height: 1.5;
      }
      .log-entry {
        margin-bottom: 12px;
      }
      .log-entry:last-child {
        margin-bottom: 0;
      }
      .log-entry strong {
        color: #1d4ed8;
      }
      .log-entry.error strong {
        color: #dc2626;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        background: rgba(148, 163, 184, 0.18);
      }
      .pill.ok {
        background: rgba(22, 163, 74, 0.18);
        color: #15803d;
      }
      .pill.fail {
        background: rgba(220, 38, 38, 0.18);
        color: #b91c1c;
      }
    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="branding">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>psBrowserPilot</h1>
          <p>NodeFlow ベースのブラウザ UI から任意の PowerShell フローを安全に実行</p>
        </div>
      </div>
      <div class="header-actions">
        <div class="session-bar">
          <label for="session-select" class="pill" id="session-label">セッション: なし</label>
          <select id="session-select" aria-labelledby="session-label"></select>
          <button id="create-session" type="button">新規セッション</button>
          <button id="refresh-sessions" type="button">再読み込み</button>
          <button id="close-session" type="button">セッション終了</button>
        </div>
        <div class="session-status" id="session-status">API 未接続</div>
        <button id="open-designer" type="button">Custom Nodes</button>
        <button id="load-flow" type="button">Load</button>
        <button id="save-flow" type="button">Save</button>
        <button id="clear-flow" type="button">Clear</button>
        <button id="export-script" class="primary" type="button">Export Script</button>
        <button id="run-script" class="primary" type="button">Run Script</button>
      </div>
    </header>

    <div class="app-body">
      <aside class="palette-shell" aria-label="Node palette">
        <div class="palette" id="node-palette"></div>
        <div class="palette-status-bar">
          <button
            type="button"
            id="open-settings"
            class="status-icon"
            aria-haspopup="dialog"
            aria-controls="settings-dialog"
            aria-label="設定を開く"
            aria-expanded="false"
          >⚙</button>
        </div>
      </aside>
      <main class="editor" id="editor-area">
        <canvas id="connection-layer"></canvas>
        <div id="node-layer" class="node-layer" role="application" aria-label="Node editor"></div>
      </main>
    </div>

    <section class="log-panel" id="execution-log" aria-live="polite"></section>

    <dialog id="property-editor">
      <form method="dialog" id="property-form">
        <header>
          <h2 id="property-title">Node Properties</h2>
        </header>
        <div class="property-fields" id="property-fields"></div>
        <menu class="property-actions">
          <button type="reset" id="property-cancel">Cancel</button>
          <button type="submit" class="primary">Save</button>
        </menu>
      </form>
    </dialog>

    <dialog id="settings-dialog" class="settings-dialog" aria-label="設定">
      <div class="settings-inner">
        <header class="settings-header">
          <h2>設定</h2>
          <button type="button" id="close-settings" class="settings-close" aria-label="設定を閉じる">
            ×
          </button>
        </header>
        <div class="settings-content">
          <div class="settings-group">
            <span id="theme-toggle-label" class="toggle-field-label">テーマ</span>
            <label class="toggle-switch" for="theme-toggle">
              <span class="toggle-text" id="theme-toggle-text">ダークモード</span>
              <input
                type="checkbox"
                id="theme-toggle"
                aria-labelledby="theme-toggle-label theme-toggle-text"
              />
              <span class="toggle-slider" aria-hidden="true"></span>
            </label>
          </div>
          <div class="settings-group">
            <label for="api-endpoint">API Endpoint</label>
            <input id="api-endpoint" type="text" placeholder="http://127.0.0.1:8080" />
            <button type="button" id="apply-endpoint" class="small-button">適用</button>
          </div>
        </div>
      </div>
    </dialog>

    <template id="node-template">
      <div class="node" tabindex="0">
        <header class="node-header">
          <span class="node-label"></span>
          <div class="node-actions">
            <button
              class="node-open-designer"
              title="カスタムノードエディタを開く"
              type="button"
            >&lt;&gt;</button>
            <button class="node-config" title="Edit properties" type="button">⚙</button>
            <button
              class="node-delete"
              title="ノードを削除"
              type="button"
              aria-label="ノードを削除"
            >✕</button>
          </div>
        </header>
        <div class="node-ports">
          <div class="inputs"></div>
          <div class="outputs"></div>
        </div>
      </div>
    </template>

    <aside id="node-designer" class="designer" aria-hidden="true">
      <div class="designer-panel">
        <header class="designer-header">
          <div>
            <h2>カスタムノードビルダー</h2>
            <p class="designer-caption">
              ノードの入出力ポートとスクリプトを定義し、ブラウザのストレージに保存できます。
            </p>
          </div>
          <button type="button" id="close-designer" class="designer-close" aria-label="Close designer">
            ×
          </button>
        </header>
        <div class="designer-content">
          <section class="designer-sidebar">
            <div class="designer-section">
              <div class="designer-section-header">
                <h3>保存済みノード</h3>
                <button type="button" id="create-node" class="small-button">新規</button>
              </div>
              <div id="custom-node-list" class="designer-list" role="list"></div>
            </div>
            <div class="designer-section">
              <h3>サンプル</h3>
              <p class="designer-hint">サンプルを読み込むとフォームに内容がコピーされます。</p>
              <div id="sample-node-list" class="designer-list" role="list"></div>
            </div>
          </section>
          <section class="designer-form">
            <form id="custom-node-form" autocomplete="off">
              <div class="field-group">
                <label for="node-label">表示名</label>
                <input id="node-label" name="label" type="text" placeholder="例: ファイル読込" required />
              </div>
              <div class="field-grid">
                <label>
                  ノードID
                  <input id="node-id" name="id" type="text" placeholder="例: file_loader" />
                </label>
                <label>
                  カテゴリ
                  <input id="node-category" name="category" type="text" placeholder="Custom" />
                </label>
              </div>
              <div class="field-group">
                <label for="node-inputs">入力ポート（1行につき1件）</label>
                <textarea id="node-inputs" name="inputs" rows="3" placeholder="InputValue"></textarea>
              </div>
              <div class="field-group">
                <label for="node-outputs">出力ポート（1行につき1件）</label>
                <textarea id="node-outputs" name="outputs" rows="3" placeholder="Result"></textarea>
              </div>
              <div class="field-group">
                <label for="node-constants">定数入力（ key | 値 ）</label>
                <textarea
                  id="node-constants"
                  name="constants"
                  rows="4"
                  placeholder="threshold | # TODO: set value"
                ></textarea>
              </div>
              <div class="field-group">
                <label for="node-script">スクリプト</label>
                <textarea
                  id="node-script"
                  name="script"
                  class="code-area"
                  rows="12"
                  placeholder="# {{input.Value}} や {{config.threshold}} のようなプレースホルダーを使用できます。"
                ></textarea>
              </div>
              <p id="designer-status" class="designer-status" role="status" aria-live="polite"></p>
              <div class="designer-actions">
                <button type="submit" class="primary">保存</button>
                <button type="button" id="duplicate-node">複製</button>
                <button type="button" id="reset-form">リセット</button>
              </div>
            </form>
          </section>
        </div>
      </div>
    </aside>

    <script type="module">
      import {
        listCustomNodeSpecs,
        saveCustomNodeSpec,
        deleteCustomNodeSpec,
        specsToDefinitions,
        SAMPLE_NODE_TEMPLATES,
        createEmptySpec,
      } from '../NodeFlow/core/nodeLibrary.js';
      import { NodeEditor } from '../NodeFlow/core/nodeEngine.js';
      import { loadGraph, saveGraph, clearGraph } from '../NodeFlow/storage/fileStore.js';
      import { exportScript } from '../NodeFlow/export/scriptExport.js';

      const paletteEl = document.getElementById('node-palette');
      const nodeLayer = document.getElementById('node-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const propertyDialog = document.getElementById('property-editor');
      const propertyForm = document.getElementById('property-form');
      const propertyFields = document.getElementById('property-fields');
      const nodeTemplate = document.getElementById('node-template');
      const executionLog = document.getElementById('execution-log');

      const sessionSelect = document.getElementById('session-select');
      const sessionStatus = document.getElementById('session-status');
      const sessionLabel = document.getElementById('session-label');
      const createSessionBtn = document.getElementById('create-session');
      const closeSessionBtn = document.getElementById('close-session');
      const refreshSessionsBtn = document.getElementById('refresh-sessions');
      const apiEndpointInput = document.getElementById('api-endpoint');
      const applyEndpointBtn = document.getElementById('apply-endpoint');

      const SETTINGS_KEY = 'psbrowserpilot.settings';

      const loadSettings = () => {
        try {
          const stored = localStorage.getItem(SETTINGS_KEY);
          if (!stored) return null;
          return JSON.parse(stored);
        } catch (error) {
          console.warn('Failed to load settings', error);
          return null;
        }
      };

      const persistSettings = (settings) => {
        try {
          localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        } catch (error) {
          console.warn('Failed to persist settings', error);
        }
      };

      const settings = loadSettings() || {
        endpoint: 'http://127.0.0.1:8080',
        theme: 'auto',
        sessionId: null,
      };

      let editor;
      let customSpecs = listCustomNodeSpecs();

      const updateSessionLabel = () => {
        const selectedId = sessionSelect.value;
        if (!selectedId) {
          sessionLabel.textContent = 'セッション: なし';
          return;
        }
        const selectedOption = sessionSelect.options[sessionSelect.selectedIndex];
        const label = selectedOption?.textContent || selectedId;
        sessionLabel.textContent = `セッション: ${label}`;
      };

      const appendLogEntry = ({ ok, exitCode, stdout, errors, script, durationMs, endpoint }) => {
        const container = document.createElement('div');
        container.className = `log-entry${ok ? '' : ' error'}`;
        const header = document.createElement('div');
        header.innerHTML = `<strong>${ok ? 'SUCCESS' : 'FAILED'}</strong> <span class="pill ${ok ? 'ok' : 'fail'}">exit ${exitCode}</span>`;
        container.appendChild(header);
        if (endpoint) {
          const endpointEl = document.createElement('div');
          endpointEl.textContent = `Endpoint: ${endpoint}`;
          container.appendChild(endpointEl);
        }
        if (durationMs !== undefined) {
          const timeEl = document.createElement('div');
          timeEl.textContent = `Duration: ${durationMs} ms`;
          container.appendChild(timeEl);
        }
        if (script) {
          const scriptEl = document.createElement('pre');
          scriptEl.textContent = script;
          container.appendChild(scriptEl);
        }
        if (stdout) {
          const stdoutEl = document.createElement('pre');
          stdoutEl.textContent = stdout;
          container.appendChild(stdoutEl);
        }
        if (errors?.length) {
          const errorList = document.createElement('ul');
          errors.forEach((err) => {
            const item = document.createElement('li');
            item.textContent = err.message || err;
            errorList.appendChild(item);
          });
          container.appendChild(errorList);
        }
        executionLog.appendChild(container);
        executionLog.scrollTop = executionLog.scrollHeight;
      };

      const setSessionStatus = (text, state = 'info') => {
        sessionStatus.textContent = text;
        sessionStatus.dataset.state = state;
      };

      const endpointUrl = () => settings.endpoint?.replace(/\/$/, '') || 'http://127.0.0.1:8080';

      const apiCall = async (path, options = {}) => {
        const url = `${endpointUrl()}${path}`;
        try {
          const response = await fetch(url, {
            headers: { 'Content-Type': 'application/json' },
            ...options,
          });
          const text = await response.text();
          const json = text ? JSON.parse(text) : {};
          if (!response.ok) {
            throw new Error(json?.error || response.statusText || 'Request failed');
          }
          return json;
        } catch (error) {
          console.error('API call failed', path, error);
          throw error;
        }
      };

      const refreshSessions = async () => {
        try {
          setSessionStatus('セッション一覧を取得中...', 'loading');
          const result = await apiCall('/sessions', { method: 'GET' });
          sessionSelect.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '（セッションを選択）';
          sessionSelect.appendChild(placeholder);
          (result.sessions || []).forEach((session) => {
            const option = document.createElement('option');
            option.value = session.id;
            option.textContent = session.name ? `${session.name} (${session.id})` : session.id;
            sessionSelect.appendChild(option);
          });
          if (settings.sessionId) {
            const existing = Array.from(sessionSelect.options).find((opt) => opt.value === settings.sessionId);
            if (existing) {
              sessionSelect.value = settings.sessionId;
            } else {
              settings.sessionId = null;
            }
          }
          updateSessionLabel();
          persistSettings(settings);
          if (result.sessions?.length) {
            setSessionStatus(`${result.sessions.length} セッション`, 'ok');
          } else {
            setSessionStatus('セッションなし', 'info');
          }
        } catch (error) {
          setSessionStatus(`セッション取得失敗: ${error.message}`, 'error');
        }
      };

      const ensureSessionSelection = () => {
        if (sessionSelect.value) {
          settings.sessionId = sessionSelect.value;
          persistSettings(settings);
          updateSessionLabel();
          return sessionSelect.value;
        }
        return null;
      };

      const createSession = async () => {
        const name = prompt('セッション名 (任意) を入力してください');
        try {
          setSessionStatus('セッション作成中...', 'loading');
          const result = await apiCall('/sessions', {
            method: 'POST',
            body: JSON.stringify({ name }),
          });
          settings.sessionId = result.session?.id || null;
          persistSettings(settings);
          await refreshSessions();
          if (settings.sessionId) {
            sessionSelect.value = settings.sessionId;
            updateSessionLabel();
            setSessionStatus(`セッション作成: ${settings.sessionId}`, 'ok');
          }
        } catch (error) {
          setSessionStatus(`セッション作成失敗: ${error.message}`, 'error');
        }
      };

      const closeSession = async () => {
        const sessionId = ensureSessionSelection();
        if (!sessionId) {
          alert('終了するセッションを選択してください。');
          return;
        }
        if (!confirm(`セッション ${sessionId} を終了しますか？`)) {
          return;
        }
        try {
          setSessionStatus('セッション終了中...', 'loading');
          await apiCall(`/sessions/${sessionId}`, { method: 'DELETE' });
          if (settings.sessionId === sessionId) {
            settings.sessionId = null;
            persistSettings(settings);
          }
          await refreshSessions();
          setSessionStatus('セッションを終了しました', 'ok');
        } catch (error) {
          setSessionStatus(`セッション終了失敗: ${error.message}`, 'error');
        }
      };

      const executeWithPowerShell = async (script) => {
        if (!script) {
          return { ok: false, exitCode: -1, stdout: '', errors: [{ message: '生成されたスクリプトが空です。' }] };
        }
        const payload = {
          script,
          sessionId: ensureSessionSelection(),
        };
        try {
          setSessionStatus('スクリプト実行中...', 'loading');
          const result = await apiCall('/commands', {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          setSessionStatus('スクリプト実行完了', 'ok');
          appendLogEntry({ ...result, script, endpoint: endpointUrl() });
          return result;
        } catch (error) {
          appendLogEntry({
            ok: false,
            exitCode: 1,
            stdout: '',
            errors: [{ message: error.message }],
            script,
            endpoint: endpointUrl(),
          });
          setSessionStatus(`実行失敗: ${error.message}`, 'error');
          throw error;
        }
      };

      const showToast = (message) => {
        if (!message) return;
        const div = document.createElement('div');
        div.textContent = message;
        div.className = 'toast';
        document.body.appendChild(div);
        requestAnimationFrame(() => {
          div.classList.add('visible');
        });
        setTimeout(() => {
          div.classList.remove('visible');
          setTimeout(() => div.remove(), 240);
        }, 1800);
      };

      const refreshLibrary = ({ persist = true } = {}) => {
        customSpecs = listCustomNodeSpecs();
        if (editor) {
          editor.setLibrary(specsToDefinitions(customSpecs), { persist });
        }
        renderCustomNodeList();
      };

      const designerEl = document.getElementById('node-designer');
      const openDesignerBtn = document.getElementById('open-designer');
      const closeDesignerBtn = document.getElementById('close-designer');
      const newNodeBtn = document.getElementById('create-node');
      const customListEl = document.getElementById('custom-node-list');
      const sampleListEl = document.getElementById('sample-node-list');
      const designerForm = document.getElementById('custom-node-form');
      const resetFormBtn = document.getElementById('reset-form');
      const duplicateNodeBtn = document.getElementById('duplicate-node');
      const designerStatus = document.getElementById('designer-status');
      const scriptField = document.getElementById('node-script');
      const openSettingsBtn = document.getElementById('open-settings');
      const settingsDialog = document.getElementById('settings-dialog');
      const closeSettingsBtn = document.getElementById('close-settings');
      const themeToggle = document.getElementById('theme-toggle');

      const THEME_STORAGE_KEY = 'nodeflow.theme';
      const CONSTANT_PLACEHOLDER = '# TODO: set value';

      const fields = {
        id: document.getElementById('node-id'),
        label: document.getElementById('node-label'),
        category: document.getElementById('node-category'),
        inputs: document.getElementById('node-inputs'),
        outputs: document.getElementById('node-outputs'),
        constants: document.getElementById('node-constants'),
        script: scriptField,
      };

      let originalId = '';
      let designerInitialized = false;

      const applyTheme = (theme) => {
        const mode = theme === 'dark' ? 'dark' : 'light';
        document.body.classList.toggle('theme-dark', mode === 'dark');
        document.body.classList.toggle('theme-light', mode === 'light');
        document.documentElement.style.setProperty('color-scheme', mode);
        if (themeToggle) {
          themeToggle.checked = mode === 'dark';
        }
      };

      const detectPreferredTheme = () =>
        window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

      const loadStoredTheme = () => {
        try {
          const stored = localStorage.getItem(THEME_STORAGE_KEY);
          return stored === 'dark' || stored === 'light' ? stored : null;
        } catch (error) {
          console.warn('Failed to read theme preference', error);
          return null;
        }
      };

      const persistTheme = (theme) => {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, theme);
        } catch (error) {
          console.warn('Failed to store theme preference', error);
        }
      };

      const initializeTheme = () => {
        const stored = loadStoredTheme();
        const initial = stored || detectPreferredTheme();
        applyTheme(initial);
        settings.theme = initial;
        persistSettings(settings);
      };

      initializeTheme();

      themeToggle?.addEventListener('change', () => {
        const mode = themeToggle.checked ? 'dark' : 'light';
        applyTheme(mode);
        persistTheme(mode);
        settings.theme = mode;
        persistSettings(settings);
      });

      const openSettings = () => {
        if (!settingsDialog) return;
        if (typeof settingsDialog.showModal === 'function' && !settingsDialog.open) {
          settingsDialog.showModal();
          openSettingsBtn?.setAttribute('aria-expanded', 'true');
        }
      };

      const closeSettings = ({ returnFocus = false } = {}) => {
        if (!settingsDialog) return;
        if (settingsDialog.open) {
          settingsDialog.close();
        }
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
        if (returnFocus) {
          openSettingsBtn?.focus();
        }
      };

      openSettingsBtn?.addEventListener('click', () => {
        apiEndpointInput.value = endpointUrl();
        openSettings();
      });

      closeSettingsBtn?.addEventListener('click', () => {
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('cancel', (event) => {
        event.preventDefault();
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('close', () => {
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
      });

      applyEndpointBtn?.addEventListener('click', () => {
        const newEndpoint = apiEndpointInput.value.trim();
        if (!newEndpoint) {
          alert('エンドポイントを入力してください。');
          return;
        }
        settings.endpoint = newEndpoint;
        persistSettings(settings);
        closeSettings({ returnFocus: true });
        refreshSessions();
      });

      const sanitizeToken = (value) =>
        String(value ?? '')
          .trim()
          .replace(/\s+/g, '_')
          .replace(/[^A-Za-z0-9_]/g, '_');

      const parsePortList = (raw) =>
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => sanitizeToken(line))
          .filter((line, index, self) => line && self.indexOf(line) === index);

      const parseConstants = (raw) =>
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => {
            const parts = line.split('|').map((part) => part.trim());
            const key = sanitizeToken(parts[0]);
            if (!key) return null;
            const defaultValue =
              parts.length >= 3
                ? parts[2]
                : parts[1]
                ? parts[1]
                : CONSTANT_PLACEHOLDER;
            return { key, default: defaultValue || CONSTANT_PLACEHOLDER };
          })
          .filter((constant, index, self) => constant && self.findIndex((item) => item.key === constant.key) === index);

      const formatConstants = (constants) =>
        (constants || [])
          .map((constant) => `${constant.key} | ${constant.default}`)
          .join('\n');

      const cloneSpec = (spec) => {
        if (!spec) return null;
        return {
          ...spec,
          inputs: [...(spec.inputs || [])],
          outputs: [...(spec.outputs || [])],
          constants: (spec.constants || []).map((constant) => ({ ...constant })),
        };
      };

      const duplicateSpecWithNewId = (spec) => {
        const baseId = sanitizeToken(spec.id || spec.label || 'custom_node').toLowerCase();
        let suffix = 1;
        let candidate = `${baseId}_${suffix}`;
        while (customSpecs.some((node) => node.id === candidate)) {
          suffix += 1;
          candidate = `${baseId}_${suffix}`;
        }
        const duplicated = { ...cloneSpec(spec), id: candidate, label: `${spec.label} Copy` };
        saveCustomNodeSpec(duplicated);
        refreshLibrary();
        return duplicated;
      };

      const removeCustomNodeSpecs = (ids, { skipConfirm = false, silent = false } = {}) => {
        const specs = customSpecs.filter((spec) => ids.includes(spec.id));
        if (!specs.length) {
          return { removedIds: [], cancelled: false };
        }
        if (!skipConfirm) {
          const message =
            specs.length === 1
              ? `${specs[0].label} を削除しますか？`
              : `${specs.length} 件のカスタムノードを削除しますか？`;
          if (!confirm(message)) {
            return { removedIds: [], cancelled: true };
          }
        }

        specs.forEach((spec) => deleteCustomNodeSpec(spec.id));
        refreshLibrary();

        if (specs.some((spec) => spec.id === originalId)) {
          if (customSpecs.length) {
            loadSpecIntoForm(customSpecs[0]);
          } else {
            loadSpecIntoForm(createEmptySpec());
          }
        }

        if (!silent) {
          showToast(
            specs.length === 1
              ? 'カスタムノードを削除しました。'
              : `${specs.length}件のカスタムノードを削除しました。`
          );
        }

        return {
          removedIds: specs.map((spec) => spec.id),
          cancelled: false,
        };
      };

      const deleteCustomNodeById = (specId, options = {}) => {
        const result = removeCustomNodeSpecs([specId], options);
        if (result.cancelled) {
          return false;
        }
        return result;
      };

      const deleteCustomNodesByIds = (ids, options = {}) => removeCustomNodeSpecs(ids, options);

      const loadSpecIntoForm = (spec, { fromSample = false } = {}) => {
        originalId = fromSample ? '' : spec.id || '';
        fields.label.value = spec.label || '';
        fields.id.value = fromSample ? '' : spec.id || '';
        fields.category.value = fromSample ? 'Custom' : spec.category || 'Custom';
        fields.inputs.value = (spec.inputs || []).join('\n');
        fields.outputs.value = (spec.outputs || []).join('\n');
        fields.constants.value = formatConstants(spec.constants || []);
        fields.script.value = spec.script || '';
        designerStatus.textContent = fromSample
          ? 'サンプルノードを読み込みました。編集して保存するとカスタムノードとして登録されます。'
          : spec.id
          ? `編集中: ${spec.id}`
          : '新しいノードを作成しています。';
      };

      const renderCustomNodeList = () => {
        customListEl.innerHTML = '';
        if (!customSpecs.length) {
          const empty = document.createElement('p');
          empty.className = 'designer-empty';
          empty.textContent = 'まだカスタムノードがありません。';
          customListEl.appendChild(empty);
          return;
        }
        customSpecs.forEach((spec) => {
          const item = document.createElement('div');
          item.className = 'designer-list-item';
          const editButton = document.createElement('button');
          editButton.type = 'button';
          editButton.className = 'designer-link';
          editButton.textContent = spec.label;
          editButton.addEventListener('click', () => loadSpecIntoForm(spec));
          const meta = document.createElement('span');
          meta.className = 'designer-meta';
          meta.textContent = spec.category || 'Custom';
          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'designer-remove';
          removeButton.textContent = '削除';
          removeButton.addEventListener('click', (event) => {
            event.stopPropagation();
            deleteCustomNodeById(spec.id);
          });
          item.append(editButton, meta, removeButton);
          customListEl.appendChild(item);
        });
      };

      const renderSampleList = () => {
        sampleListEl.innerHTML = '';
        SAMPLE_NODE_TEMPLATES.forEach((sample) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'designer-sample';
          button.innerHTML = `<strong>${sample.label}</strong><span>${sample.description}</span>`;
          button.addEventListener('click', () =>
            loadSpecIntoForm(
              {
                ...sample,
                id: '',
                label: sample.label.replace(/^Sample:\s*/i, ''),
                category: 'Custom',
                inputs: [...(sample.inputs || [])],
                outputs: [...(sample.outputs || [])],
                constants: (sample.constants || []).map((constant) => ({ ...constant })),
                script: sample.script,
              },
              { fromSample: true }
            )
          );
          sampleListEl.appendChild(button);
        });
      };

      const ensureDesignerInitialized = () => {
        if (designerInitialized) return;
        renderSampleList();
        if (customSpecs.length) {
          loadSpecIntoForm(customSpecs[0]);
        } else {
          loadSpecIntoForm(createEmptySpec());
        }
        designerInitialized = true;
      };

      const openDesigner = () => {
        ensureDesignerInitialized();
        designerEl.classList.add('open');
      };

      const closeDesigner = () => {
        designerEl.classList.remove('open');
      };

      designerForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const label = fields.label.value.trim();
        if (!label) {
          alert('表示名を入力してください。');
          return;
        }
        const spec = {
          id: sanitizeToken(fields.id.value.trim()) || originalId || sanitizeToken(label).toLowerCase(),
          label,
          category: fields.category.value.trim() || 'Custom',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
        };
        saveCustomNodeSpec(spec);
        refreshLibrary();
        originalId = spec.id;
        showToast('カスタムノードを保存しました。');
      });

      resetFormBtn.addEventListener('click', () => {
        loadSpecIntoForm(createEmptySpec());
      });

      duplicateNodeBtn.addEventListener('click', () => {
        const label = fields.label.value.trim();
        const spec = {
          id: sanitizeToken(fields.id.value.trim()) || originalId || sanitizeToken(label).toLowerCase(),
          label: label || 'Untitled node',
          category: fields.category.value.trim() || 'Custom',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
        };
        const saved = duplicateSpecWithNewId(spec);
        if (!saved) {
          return;
        }
        showToast('カスタムノードを複製しました。');
        loadSpecIntoForm(saved);
      });

      propertyForm.addEventListener('submit', (event) => {
        event.preventDefault();
        editor?.commitNodeProperties();
        propertyDialog.close();
      });

      propertyDialog.addEventListener('close', () => {
        propertyFields.innerHTML = '';
      });

      document.getElementById('property-cancel').addEventListener('click', () => {
        editor?.cancelNodeProperties();
      });

      editor = new NodeEditor({
        paletteEl,
        nodeLayer,
        connectionLayer,
        propertyDialog,
        propertyFields,
        nodeTemplate,
        library: specsToDefinitions(customSpecs),
        onEditNodeProperties: (fields) => {
          propertyFields.innerHTML = '';
          fields.forEach((field) => {
            const wrapper = document.createElement('label');
            wrapper.textContent = field.label;
            const input = document.createElement(field.multiline ? 'textarea' : 'input');
            input.value = field.value ?? '';
            if (field.multiline) {
              input.rows = 4;
            }
            input.addEventListener('input', (event) => field.onChange(event.target.value));
            wrapper.appendChild(input);
            propertyFields.appendChild(wrapper);
          });
          propertyDialog.showModal();
        },
        onRemoveCustomNodes: (ids, options) => deleteCustomNodesByIds(ids, options),
        persistence: {
          load: loadGraph,
          save: saveGraph,
          clear: clearGraph,
        },
      });

      window.addEventListener('resize', () => editor.resize());

      document.getElementById('export-script').addEventListener('click', () => editor.exportScript());
      document.getElementById('run-script').addEventListener('click', async () => {
        if (!editor) {
          return;
        }
        let builtScript = '';
        try {
          builtScript = editor.generateScript();
        } catch (error) {
          alert(error.message);
          return;
        }

        let result;
        try {
          result = await executeWithPowerShell(builtScript);
        } catch (error) {
          alert(`PowerShell API 呼び出し中に例外が発生しました:\n${error.message}`);
          return;
        }
        if (!result?.ok) {
          const errorMessage = result?.error || (result?.errors && result.errors[0]?.message) || '不明なエラー';
          alert(`PowerShell 実行時にエラーが発生しました (exit ${result?.exitCode ?? 'unknown'}):\n${errorMessage}`);
          return;
        }

        const output = (result.stdout || '').trim();
        if (output) {
          alert(output);
        } else {
          showToast('PowerShell スクリプトを実行しました。');
        }
      });
      document.getElementById('save-flow').addEventListener('click', () => editor.persistGraph());
      document.getElementById('load-flow').addEventListener('click', () => editor.restoreGraph());
      document.getElementById('clear-flow').addEventListener('click', () => editor.clearGraph());

      openDesignerBtn.addEventListener('click', openDesigner);
      closeDesignerBtn.addEventListener('click', closeDesigner);
      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && designerEl.classList.contains('open')) {
          closeDesigner();
        }
      });

      newNodeBtn.addEventListener('click', () => {
        loadSpecIntoForm(createEmptySpec());
        designerStatus.textContent = '新しいノードを作成しています。';
      });

      sessionSelect.addEventListener('change', () => {
        settings.sessionId = sessionSelect.value || null;
        persistSettings(settings);
        updateSessionLabel();
      });

      createSessionBtn.addEventListener('click', createSession);
      closeSessionBtn.addEventListener('click', closeSession);
      refreshSessionsBtn.addEventListener('click', refreshSessions);

      refreshLibrary({ persist: false });
      refreshSessions();
    </script>
  </body>
</html>
