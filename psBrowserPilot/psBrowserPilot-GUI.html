<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>psBrowserPilot - PowerShell Browser Orchestrator</title>
    <link rel="stylesheet" href="../NodeFlow/ui/editor.css" />
    <style>
      .app-body {
        display: grid;
        grid-template-columns: 280px minmax(520px, 1fr) 320px;
        gap: 12px;
        padding: 0 16px 24px;
      }

      .palette-shell {
        min-width: 240px;
      }

      .editor {
        position: relative;
        min-height: 560px;
      }

      .console-panel {
        background: var(--surface, rgba(255, 255, 255, 0.82));
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.32);
        box-shadow: 0 8px 24px rgba(15, 23, 42, 0.12);
        padding: 20px 18px;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .console-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
      }

      .console-header h2 {
        margin: 0;
        font-size: 18px;
      }

      .console-caption {
        margin: 4px 0 0;
        font-size: 12px;
        color: var(--muted, #64748b);
      }

      .console-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .console-actions button {
        border-radius: 999px;
        border: 1px solid rgba(59, 130, 246, 0.25);
        background: rgba(59, 130, 246, 0.08);
        color: var(--accent, #2563eb);
        padding: 6px 14px;
        font-size: 13px;
        cursor: pointer;
      }

      .console-actions button:hover {
        background: rgba(59, 130, 246, 0.16);
      }

      .session-meta {
        display: grid;
        gap: 6px;
        font-size: 13px;
        line-height: 1.5;
      }

      .session-meta span {
        color: var(--muted, #64748b);
      }

      .session-meta strong {
        color: var(--text, #1f2937);
        font-weight: 600;
      }

      .api-input {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 12px;
      }

      .api-input input {
        border: 1px solid rgba(148, 163, 184, 0.6);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 13px;
      }

      .execution-log {
        display: flex;
        flex-direction: column;
        gap: 12px;
        overflow-y: auto;
        max-height: 420px;
        padding-right: 4px;
      }

      .log-entry {
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        padding: 12px 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        background: rgba(248, 250, 252, 0.9);
      }

      .log-entry--error {
        border-color: rgba(239, 68, 68, 0.4);
        background: rgba(254, 226, 226, 0.6);
      }

      .log-entry--ok {
        border-color: rgba(16, 185, 129, 0.35);
        background: rgba(236, 253, 245, 0.75);
      }

      .log-entry__header {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: baseline;
        font-size: 12px;
        color: var(--muted, #64748b);
      }

      .log-entry__status {
        font-weight: 600;
      }

      .log-entry__section h4 {
        margin: 0 0 4px;
        font-size: 13px;
        color: var(--text, #1f2937);
      }

      .log-entry__section pre {
        background: rgba(15, 23, 42, 0.06);
        border-radius: 10px;
        padding: 10px;
        margin: 0;
        white-space: pre-wrap;
        word-break: break-all;
        font-size: 12px;
      }

      .stream-list {
        display: grid;
        gap: 4px;
        font-size: 12px;
      }

      .stream-list span {
        background: rgba(15, 23, 42, 0.08);
        border-radius: 10px;
        padding: 6px 8px;
        display: inline-block;
      }

      .empty-log {
        font-size: 12px;
        color: var(--muted, #94a3b8);
        text-align: center;
        padding: 24px 12px;
      }

      @media (max-width: 1280px) {
        .app-body {
          grid-template-columns: minmax(260px, 1fr);
          grid-auto-rows: auto;
        }

        .console-panel {
          order: 3;
        }

        .palette-shell {
          order: 1;
        }

        .editor {
          order: 2;
          min-height: 480px;
        }
      }
    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="branding">
        <div class="logo" aria-hidden="true"></div>
        <h1>psBrowserPilot</h1>
      </div>
      <div class="header-actions">
        <button id="open-designer" type="button">Custom Nodes</button>
        <button id="load-flow" type="button">Load</button>
        <button id="save-flow" type="button">Save</button>
        <button id="clear-flow" type="button">Clear</button>
        <button id="export-script" class="primary" type="button">Export Script</button>
        <button id="run-script" class="primary" type="button">Run via PowerShell</button>
      </div>
    </header>

    <div class="app-body">
      <aside class="palette-shell" aria-label="Node palette">
        <div class="palette" id="node-palette"></div>
        <div class="palette-status-bar">
          <button
            type="button"
            id="open-settings"
            class="status-icon"
            aria-haspopup="dialog"
            aria-controls="settings-dialog"
            aria-label="設定を開く"
            aria-expanded="false"
          >⚙</button>
        </div>
      </aside>
      <main class="editor" id="editor-area">
        <canvas id="connection-layer"></canvas>
        <div id="node-layer" class="node-layer" role="application" aria-label="Node editor"></div>
      </main>
      <aside class="console-panel" id="console-panel" aria-label="Execution console">
        <div class="console-header">
          <div>
            <h2>Execution Console</h2>
            <p class="console-caption">
              NodeFlow で組み立てたスクリプトをブラウザ経由で PowerShell に送信し、結果とストリームを確認できます。
            </p>
          </div>
          <div class="console-actions">
            <button id="new-session" type="button">New session</button>
            <button id="refresh-history" type="button">Refresh history</button>
          </div>
        </div>
        <label class="api-input" for="api-root">
          <span>PowerShell API endpoint</span>
          <input id="api-root" name="api-root" type="text" value="http://127.0.0.1:8080" spellcheck="false" />
        </label>
        <div class="session-meta">
          <span>Session ID: <strong id="session-id">--</strong></span>
          <span>Status: <strong id="session-status">Disconnected</strong></span>
          <span>Commands executed: <strong id="command-count">0</strong></span>
        </div>
        <div class="execution-log" id="execution-log" role="log" aria-live="polite">
          <div class="empty-log" id="empty-log">
            まだ実行履歴がありません。ノードを組み立てて「Run via PowerShell」を押してください。
          </div>
        </div>
      </aside>
    </div>

    <dialog id="property-editor">
      <form method="dialog" id="property-form">
        <header>
          <h2 id="property-title">Node Properties</h2>
        </header>
        <div class="property-fields" id="property-fields"></div>
        <menu class="property-actions">
          <button type="reset" id="property-cancel">Cancel</button>
          <button type="submit" class="primary">Save</button>
        </menu>
      </form>
    </dialog>

    <dialog id="settings-dialog" class="settings-dialog" aria-label="設定">
      <div class="settings-inner">
        <header class="settings-header">
          <h2>設定</h2>
          <button type="button" id="close-settings" class="settings-close" aria-label="設定を閉じる">
            ×
          </button>
        </header>
        <div class="settings-content">
          <div class="settings-group">
            <span id="theme-toggle-label" class="toggle-field-label">テーマ</span>
            <label class="toggle-switch" for="theme-toggle">
              <span class="toggle-text" id="theme-toggle-text">ダークモード</span>
              <input
                type="checkbox"
                id="theme-toggle"
                aria-labelledby="theme-toggle-label theme-toggle-text"
              />
              <span class="toggle-slider" aria-hidden="true"></span>
            </label>
          </div>
        </div>
      </div>
    </dialog>

    <template id="node-template">
      <div class="node" tabindex="0">
        <header class="node-header">
          <span class="node-label"></span>
          <div class="node-actions">
            <button
              class="node-open-designer"
              title="カスタムノードエディタを開く"
              type="button"
            >&lt;&gt;</button>
            <button class="node-config" title="Edit properties" type="button">⚙</button>
            <button
              class="node-delete"
              title="ノードを削除"
              type="button"
              aria-label="ノードを削除"
            >✕</button>
          </div>
        </header>
        <div class="node-ports">
          <div class="inputs"></div>
          <div class="outputs"></div>
        </div>
      </div>
    </template>

    <aside id="node-designer" class="designer" aria-hidden="true">
      <div class="designer-panel">
        <header class="designer-header">
          <div>
            <h2>カスタムノードビルダー</h2>
            <p class="designer-caption">
              ノードの入出力ポートとスクリプトを定義し、ブラウザのストレージに保存できます。
            </p>
          </div>
          <button type="button" id="close-designer" class="designer-close" aria-label="Close designer">
            ×
          </button>
        </header>
        <div class="designer-content">
          <section class="designer-sidebar">
            <div class="designer-section">
              <div class="designer-section-header">
                <h3>保存済みノード</h3>
                <button type="button" id="create-node" class="small-button">新規</button>
              </div>
              <div id="custom-node-list" class="designer-list" role="list"></div>
            </div>
            <div class="designer-section">
              <h3>サンプル</h3>
              <p class="designer-hint">サンプルを読み込むとフォームに内容がコピーされます。</p>
              <div id="sample-node-list" class="designer-list" role="list"></div>
            </div>
          </section>
          <section class="designer-form">
            <form id="custom-node-form" autocomplete="off">
              <div class="field-group">
                <label for="node-label">表示名</label>
                <input id="node-label" name="label" type="text" placeholder="例: ファイル読込" required />
              </div>
              <div class="field-grid">
                <label>
                  ノードID
                  <input id="node-id" name="id" type="text" placeholder="例: file_loader" />
                </label>
                <label>
                  カテゴリ
                  <input id="node-category" name="category" type="text" placeholder="Custom" />
                </label>
              </div>
              <div class="field-group">
                <label for="node-inputs">入力ポート（1行につき1件）</label>
                <textarea id="node-inputs" name="inputs" rows="3" placeholder="InputValue"></textarea>
              </div>
              <div class="field-group">
                <label for="node-outputs">出力ポート（1行につき1件）</label>
                <textarea id="node-outputs" name="outputs" rows="3" placeholder="Result"></textarea>
              </div>
              <div class="field-group">
                <label for="node-constants">定数入力（ key | 値 ）</label>
                <textarea
                  id="node-constants"
                  name="constants"
                  rows="4"
                  placeholder="threshold | # TODO: set value"
                ></textarea>
              </div>
              <div class="field-group">
                <label for="node-script">スクリプト</label>
                <textarea
                  id="node-script"
                  name="script"
                  class="code-area"
                  rows="12"
                  placeholder="# {{input.Value}} や {{config.threshold}} のようなプレースホルダーを使用できます。"
                ></textarea>
              </div>
              <p id="designer-status" class="designer-status" role="status" aria-live="polite"></p>
              <div class="designer-actions">
                <button type="submit" class="primary">保存</button>
                <button type="button" id="duplicate-node">複製</button>
                <button type="button" id="reset-form">リセット</button>
              </div>
            </form>
          </section>
        </div>
      </div>
    </aside>

    <script type="module">
      import {
        listCustomNodeSpecs,
        saveCustomNodeSpec,
        deleteCustomNodeSpec,
        specsToDefinitions,
        SAMPLE_NODE_TEMPLATES,
        createEmptySpec,
      } from '../NodeFlow/core/nodeLibrary.js';
      import { NodeEditor } from '../NodeFlow/core/nodeEngine.js';
      import { loadGraph, saveGraph, clearGraph } from '../NodeFlow/storage/fileStore.js';
      import { exportScript } from '../NodeFlow/export/scriptExport.js';

      const paletteEl = document.getElementById('node-palette');
      const nodeLayer = document.getElementById('node-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const propertyDialog = document.getElementById('property-editor');
      const propertyForm = document.getElementById('property-form');
      const propertyFields = document.getElementById('property-fields');
      const nodeTemplate = document.getElementById('node-template');
      const executionLogEl = document.getElementById('execution-log');
      const emptyLogEl = document.getElementById('empty-log');
      const sessionIdEl = document.getElementById('session-id');
      const sessionStatusEl = document.getElementById('session-status');
      const commandCountEl = document.getElementById('command-count');
      const newSessionBtn = document.getElementById('new-session');
      const refreshHistoryBtn = document.getElementById('refresh-history');
      const apiInput = document.getElementById('api-root');
      const runButton = document.getElementById('run-script');

      let customSpecs = listCustomNodeSpecs();
      let editor;
      const sanitizeApiRoot = (value) => {
        if (!value) {
          return '';
        }
        const trimmed = value.trim();
        return trimmed.endsWith('/') ? trimmed.slice(0, -1) : trimmed;
      };

      const getApiRoot = () => sanitizeApiRoot(apiInput?.value || 'http://127.0.0.1:8080');

      const fetchJson = async (url, options = {}) => {
        const requestInit = { ...options };
        if (requestInit.body && !requestInit.headers) {
          requestInit.headers = { 'Content-Type': 'application/json' };
        } else if (requestInit.body && requestInit.headers) {
          requestInit.headers = { 'Content-Type': 'application/json', ...requestInit.headers };
        }

        const response = await fetch(url, requestInit);
        const raw = await response.text();
        let data = null;
        if (raw) {
          try {
            data = JSON.parse(raw);
          } catch (error) {
            throw new Error(`Invalid JSON response: ${error.message}`);
          }
        }

        if (!response.ok) {
          const message = data?.error || response.statusText || `HTTP ${response.status}`;
          const err = new Error(message);
          err.status = response.status;
          err.payload = data;
          throw err;
        }

        return data;
      };

      const formatDuration = (ms) => {
        if (typeof ms !== 'number' || Number.isNaN(ms)) {
          return '';
        }
        if (ms >= 1000) {
          return `${(ms / 1000).toFixed(2)} s`;
        }
        return `${ms} ms`;
      };

      const toLocalTime = (value) => {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return value;
        }
        return date.toLocaleString();
      };

      const collectMessages = (items, selector = (item) => item) => {
        if (!Array.isArray(items) || items.length === 0) {
          return [];
        }
        return items
          .map((item) => {
            try {
              const value = selector(item);
              if (typeof value === 'string') {
                return value.trim();
              }
              if (value && typeof value === 'object' && 'message' in value) {
                return String(value.message ?? '');
              }
              return value ? String(value) : '';
            } catch (error) {
              return '';
            }
          })
          .filter((text) => text);
      };

      const setEmptyLogVisible = (visible) => {
        if (!emptyLogEl) return;
        emptyLogEl.style.display = visible ? 'block' : 'none';
      };

      const clearLog = () => {
        if (!executionLogEl) return;
        executionLogEl.querySelectorAll('.log-entry').forEach((entry) => entry.remove());
        setEmptyLogVisible(true);
      };

      const createTextSection = (title, text) => {
        const section = document.createElement('section');
        section.className = 'log-entry__section';
        const heading = document.createElement('h4');
        heading.textContent = title;
        section.appendChild(heading);
        const pre = document.createElement('pre');
        pre.textContent = text || '';
        section.appendChild(pre);
        return section;
      };

      const createListSection = (title, items) => {
        if (!items || items.length === 0) {
          return null;
        }
        const section = document.createElement('section');
        section.className = 'log-entry__section';
        const heading = document.createElement('h4');
        heading.textContent = title;
        section.appendChild(heading);
        const list = document.createElement('div');
        list.className = 'stream-list';
        items.forEach((message) => {
          const span = document.createElement('span');
          span.textContent = message;
          list.appendChild(span);
        });
        section.appendChild(list);
        return section;
      };

      const appendLogEntry = (entry, { prepend = true } = {}) => {
        if (!entry || !executionLogEl) {
          return;
        }
        setEmptyLogVisible(false);

        const container = document.createElement('article');
        container.className = 'log-entry';
        container.classList.add(entry.ok === false || entry.hadErrors ? 'log-entry--error' : 'log-entry--ok');

        const header = document.createElement('header');
        header.className = 'log-entry__header';
        const timeSpan = document.createElement('span');
        timeSpan.textContent = toLocalTime(entry.started);
        header.appendChild(timeSpan);
        const durationSpan = document.createElement('span');
        durationSpan.textContent = formatDuration(entry.durationMs);
        header.appendChild(durationSpan);
        const statusSpan = document.createElement('span');
        statusSpan.className = 'log-entry__status';
        statusSpan.textContent = entry.ok === false || entry.hadErrors ? 'Error' : 'Success';
        header.appendChild(statusSpan);
        container.appendChild(header);

        container.appendChild(createTextSection('Script', entry.script || ''));

        const outputText = entry.result?.outputText?.trim() ||
          (Array.isArray(entry.result?.output) ? entry.result.output.filter(Boolean).join('\n') : '');
        container.appendChild(createTextSection('Output', outputText || '(no output)'));

        const streams = entry.result?.streams || {};
        const progressMessages = collectMessages(streams.progress, (item) => {
          if (!item || typeof item !== 'object') {
            return item ? String(item) : '';
          }
          const activity = item.activity ? String(item.activity) : '';
          const status = item.status ? ` - ${item.status}` : '';
          const percent = typeof item.percent === 'number' && !Number.isNaN(item.percent)
            ? ` (${item.percent}%)`
            : '';
          const combined = `${activity}${status}${percent}`.trim();
          return combined || JSON.stringify(item);
        });
        const streamSections = [
          ['Errors', collectMessages(streams.error, (item) => item?.message ?? item)],
          ['Warnings', collectMessages(streams.warning, (item) => item?.message ?? item)],
          ['Verbose', collectMessages(streams.verbose, (item) => item?.message ?? item)],
          ['Information', collectMessages(streams.information, (item) => item?.message ?? item)],
          ['Debug', collectMessages(streams.debug, (item) => item?.message ?? item)],
          ['Progress', progressMessages],
        ];
        streamSections.forEach(([title, items]) => {
          const section = createListSection(title, items);
          if (section) {
            container.appendChild(section);
          }
        });

        if (prepend) {
          executionLogEl.prepend(container);
        } else {
          executionLogEl.appendChild(container);
        }

        const entries = executionLogEl.querySelectorAll('.log-entry');
        if (entries.length > 200) {
          entries[entries.length - 1].remove();
        }
      };

      const renderHistory = (history = []) => {
        clearLog();
        if (!Array.isArray(history) || history.length === 0) {
          return;
        }
        history.forEach((item) => appendLogEntry(item, { prepend: false }));
      };

      const updateSessionUI = (session, { statusMessage } = {}) => {
        if (!session) {
          if (sessionIdEl) sessionIdEl.textContent = '--';
          if (commandCountEl) commandCountEl.textContent = '0';
          if (sessionStatusEl) sessionStatusEl.textContent = statusMessage || 'Disconnected';
          return;
        }
        if (sessionIdEl) sessionIdEl.textContent = session.id;
        if (commandCountEl) commandCountEl.textContent = String(session.commandCount ?? 0);
        if (sessionStatusEl) sessionStatusEl.textContent = statusMessage || 'Ready';
      };

      let activeSession = null;
      let sessionPromise = null;

      const ensureSession = async () => {
        if (activeSession) {
          return activeSession;
        }
        if (sessionPromise) {
          return sessionPromise;
        }

        sessionPromise = (async () => {
          try {
            updateSessionUI(null, { statusMessage: 'Connecting…' });
            const baseUrl = getApiRoot();
            const payload = {
              name: 'browser-session',
              metadata: {
                client: 'psBrowserPilot',
                userAgent: navigator.userAgent,
                createdAt: new Date().toISOString(),
              },
            };
            const response = await fetchJson(`${baseUrl}/sessions`, {
              method: 'POST',
              body: JSON.stringify(payload),
            });
            if (!response?.session?.id) {
              throw new Error('Session creation failed.');
            }
            activeSession = response.session;
            updateSessionUI(activeSession, { statusMessage: 'Ready' });
            renderHistory([]);
            return activeSession;
          } catch (error) {
            activeSession = null;
            updateSessionUI(null, { statusMessage: 'Disconnected' });
            throw error;
          } finally {
            sessionPromise = null;
          }
        })();

        return sessionPromise;
      };

      const loadHistory = async () => {
        const session = await ensureSession();
        const response = await fetchJson(`${getApiRoot()}/sessions/${session.id}/history?limit=100`);
        if (Array.isArray(response?.history)) {
          renderHistory(response.history);
        }
        if (typeof response?.commandCount === 'number' && activeSession) {
          activeSession.commandCount = response.commandCount;
          updateSessionUI(activeSession);
        }
        return response;
      };

      const closeCurrentSession = async ({ silent = false } = {}) => {
        if (!activeSession) {
          return;
        }
        const session = activeSession;
        activeSession = null;
        updateSessionUI(null, { statusMessage: 'Disconnected' });
        clearLog();
        try {
          await fetch(`${getApiRoot()}/sessions/${session.id}`, { method: 'DELETE' });
        } catch (error) {
          if (!silent) {
            console.warn('Failed to close session', error);
          }
        }
      };

      const executeWithPowerShell = async (script) => {
        if (!script || !script.trim()) {
          throw new Error('生成されたスクリプトが空です。');
        }
        const session = await ensureSession();
        const response = await fetchJson(`${getApiRoot()}/sessions/${session.id}/commands`, {
          method: 'POST',
          body: JSON.stringify({
            script,
            metadata: {
              source: 'psBrowserPilot',
              generatedAt: new Date().toISOString(),
            },
          }),
        });
        if (typeof response?.commandCount === 'number' && activeSession) {
          activeSession.commandCount = response.commandCount;
          updateSessionUI(activeSession);
        }
        return response;
      };

      const showToast = (message) => {
        if (!message) return;
        const div = document.createElement('div');
        div.textContent = message;
        div.className = 'toast';
        document.body.appendChild(div);
        requestAnimationFrame(() => {
          div.classList.add('visible');
        });
        setTimeout(() => {
          div.classList.remove('visible');
          setTimeout(() => div.remove(), 240);
        }, 1800);
      };

      const refreshLibrary = ({ persist = true } = {}) => {
        customSpecs = listCustomNodeSpecs();
        if (editor) {
          editor.setLibrary(specsToDefinitions(customSpecs), { persist });
        }
        renderCustomNodeList();
      };

      const designerEl = document.getElementById('node-designer');
      const openDesignerBtn = document.getElementById('open-designer');
      const closeDesignerBtn = document.getElementById('close-designer');
      const newNodeBtn = document.getElementById('create-node');
      const customListEl = document.getElementById('custom-node-list');
      const sampleListEl = document.getElementById('sample-node-list');
      const designerForm = document.getElementById('custom-node-form');
      const resetFormBtn = document.getElementById('reset-form');
      const duplicateNodeBtn = document.getElementById('duplicate-node');
      const designerStatus = document.getElementById('designer-status');
      const scriptField = document.getElementById('node-script');
      const openSettingsBtn = document.getElementById('open-settings');
      const settingsDialog = document.getElementById('settings-dialog');
      const closeSettingsBtn = document.getElementById('close-settings');
      const themeToggle = document.getElementById('theme-toggle');

      const THEME_STORAGE_KEY = 'nodeflow.theme';
      const CONSTANT_PLACEHOLDER = '# TODO: set value';

      const fields = {
        id: document.getElementById('node-id'),
        label: document.getElementById('node-label'),
        category: document.getElementById('node-category'),
        inputs: document.getElementById('node-inputs'),
        outputs: document.getElementById('node-outputs'),
        constants: document.getElementById('node-constants'),
        script: scriptField,
      };

      let originalId = '';
      let designerInitialized = false;

      const applyTheme = (theme) => {
        const mode = theme === 'dark' ? 'dark' : 'light';
        document.body.classList.toggle('theme-dark', mode === 'dark');
        document.body.classList.toggle('theme-light', mode === 'light');
        document.documentElement.style.setProperty('color-scheme', mode);
        if (themeToggle) {
          themeToggle.checked = mode === 'dark';
        }
      };

      const detectPreferredTheme = () =>
        window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

      const loadStoredTheme = () => {
        try {
          const stored = localStorage.getItem(THEME_STORAGE_KEY);
          return stored === 'dark' || stored === 'light' ? stored : null;
        } catch (error) {
          console.warn('Failed to read theme preference', error);
          return null;
        }
      };

      const persistTheme = (theme) => {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, theme);
        } catch (error) {
          console.warn('Failed to store theme preference', error);
        }
      };

      const initializeTheme = () => {
        const stored = loadStoredTheme();
        const initial = stored || detectPreferredTheme();
        applyTheme(initial);
      };

      initializeTheme();

      themeToggle?.addEventListener('change', () => {
        const mode = themeToggle.checked ? 'dark' : 'light';
        applyTheme(mode);
        persistTheme(mode);
      });

      const openSettings = () => {
        if (!settingsDialog) return;
        if (typeof settingsDialog.showModal === 'function' && !settingsDialog.open) {
          settingsDialog.showModal();
          openSettingsBtn?.setAttribute('aria-expanded', 'true');
        }
      };

      const closeSettings = ({ returnFocus = false } = {}) => {
        if (!settingsDialog) return;
        if (settingsDialog.open) {
          settingsDialog.close();
        }
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
        if (returnFocus) {
          openSettingsBtn?.focus();
        }
      };

      openSettingsBtn?.addEventListener('click', () => {
        openSettings();
      });

      closeSettingsBtn?.addEventListener('click', () => {
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('cancel', (event) => {
        event.preventDefault();
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('close', () => {
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
      });

      const sanitizeToken = (value) =>
        String(value ?? '')
          .trim()
          .replace(/\s+/g, '_')
          .replace(/[^A-Za-z0-9_]/g, '_');

      const parsePortList = (raw) =>
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => sanitizeToken(line))
          .filter((line, index, self) => line && self.indexOf(line) === index);

      const parseConstants = (raw) =>
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean)
          .map((line) => {
            const parts = line.split('|').map((part) => part.trim());
            const key = sanitizeToken(parts[0]);
            if (!key) return null;
            const defaultValue =
              parts.length >= 3
                ? parts[2]
                : parts[1]
                ? parts[1]
                : CONSTANT_PLACEHOLDER;
            return { key, default: defaultValue || CONSTANT_PLACEHOLDER };
          })
          .filter((constant, index, self) => constant && self.findIndex((item) => item.key === constant.key) === index);

      const formatConstants = (constants) =>
        (constants || [])
          .map((constant) => `${constant.key} | ${constant.default}`)
          .join('\n');

      const cloneSpec = (spec) => {
        if (!spec) return null;
        return {
          ...spec,
          inputs: [...(spec.inputs || [])],
          outputs: [...(spec.outputs || [])],
          constants: (spec.constants || []).map((constant) => ({ ...constant })),
          script: spec.script || '',
        };
      };

      const findSpecById = (id) => customSpecs.find((spec) => spec.id === id);

      const ensureDuplicatedLabel = (label) => {
        const base = label && label.trim() ? label.trim() : 'Untitled node';
        return base.endsWith(' (複製)') ? base : `${base} (複製)`;
      };

      const generateUniqueNodeId = (seedId) => {
        const existingIds = new Set(customSpecs.map((spec) => spec.id));
        let base = sanitizeToken(seedId || '');
        if (!base) {
          base = 'custom_node';
        }
        if (!existingIds.has(base)) {
          return base;
        }
        const match = base.match(/^(.*?)(\d+)?$/);
        let prefix = match && match[1] !== undefined ? match[1] : base;
        if (!prefix) {
          prefix = base || 'custom_node';
        }
        let suffix = match && match[2] ? parseInt(match[2], 10) + 1 : 2;
        if (!Number.isFinite(suffix) || suffix < 1) {
          suffix = 2;
        }
        let candidate = `${prefix}${suffix}`;
        while (existingIds.has(candidate)) {
          suffix += 1;
          candidate = `${prefix}${suffix}`;
        }
        return candidate;
      };

      const duplicateSpecWithNewId = (spec) => {
        if (!spec) return null;
        const working = cloneSpec(spec);
        const preferredBaseId = working.id || sanitizeToken(working.label).toLowerCase();
        working.id = generateUniqueNodeId(preferredBaseId);
        working.label = ensureDuplicatedLabel(working.label);
        working.category = working.category || 'Custom';
        working.script = working.script || '';
        return saveCustomNodeSpec(working);
      };

      const duplicateCustomNodeById = (specId) => {
        const spec = findSpecById(specId);
        if (!spec) {
          return null;
        }
        const saved = duplicateSpecWithNewId(spec);
        if (saved) {
          showToast('ノードを複製しました。');
          refreshLibrary();
        }
        return saved;
      };

      const removeCustomNodeSpecs = (ids, { skipConfirm = false, silent = false } = {}) => {
        const uniqueIds = Array.isArray(ids)
          ? Array.from(new Set(ids.filter(Boolean)))
          : [];
        if (!uniqueIds.length) {
          return { removedIds: [], cancelled: false };
        }
        const specs = uniqueIds.map((id) => findSpecById(id)).filter(Boolean);
        if (!specs.length) {
          return { removedIds: [], cancelled: false };
        }
        if (!skipConfirm) {
          const message =
            specs.length === 1
              ? `${specs[0].label} を削除しますか？`
              : `${specs.length} 件のカスタムノードを削除しますか？`;
          if (!confirm(message)) {
            return { removedIds: [], cancelled: true };
          }
        }

        specs.forEach((spec) => deleteCustomNodeSpec(spec.id));
        refreshLibrary();

        if (specs.some((spec) => spec.id === originalId)) {
          if (customSpecs.length) {
            loadSpecIntoForm(customSpecs[0]);
          } else {
            loadSpecIntoForm(createEmptySpec());
          }
        }

        if (!silent) {
          showToast(
            specs.length === 1
              ? 'カスタムノードを削除しました。'
              : `${specs.length}件のカスタムノードを削除しました。`
          );
        }

        return {
          removedIds: specs.map((spec) => spec.id),
          cancelled: false,
        };
      };

      const deleteCustomNodeById = (specId, options = {}) => {
        const result = removeCustomNodeSpecs([specId], options);
        if (result.cancelled) {
          return false;
        }
        return result;
      };

      const deleteCustomNodesByIds = (ids, options = {}) => removeCustomNodeSpecs(ids, options);

      const loadSpecIntoForm = (spec, { fromSample = false } = {}) => {
        originalId = fromSample ? '' : spec.id || '';
        fields.label.value = spec.label || '';
        fields.id.value = fromSample ? '' : spec.id || '';
        fields.category.value = fromSample ? 'Custom' : spec.category || 'Custom';
        fields.inputs.value = (spec.inputs || []).join('\n');
        fields.outputs.value = (spec.outputs || []).join('\n');
        fields.constants.value = formatConstants(spec.constants || []);
        fields.script.value = spec.script || '';
        designerStatus.textContent = fromSample
          ? 'サンプルノードを読み込みました。編集して保存するとカスタムノードとして登録されます。'
          : spec.id
          ? `編集中: ${spec.id}`
          : '新しいノードを作成しています。';
      };

      const renderCustomNodeList = () => {
        customListEl.innerHTML = '';
        if (!customSpecs.length) {
          const empty = document.createElement('p');
          empty.className = 'designer-empty';
          empty.textContent = 'まだカスタムノードがありません。';
          customListEl.appendChild(empty);
          return;
        }
        customSpecs.forEach((spec) => {
          const item = document.createElement('div');
          item.className = 'designer-list-item';
          const editButton = document.createElement('button');
          editButton.type = 'button';
          editButton.className = 'designer-link';
          editButton.textContent = spec.label;
          editButton.addEventListener('click', () => loadSpecIntoForm(spec));
          const meta = document.createElement('span');
          meta.className = 'designer-meta';
          meta.textContent = spec.category || 'Custom';
          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'designer-remove';
          removeButton.textContent = '削除';
          removeButton.addEventListener('click', (event) => {
            event.stopPropagation();
            deleteCustomNodeById(spec.id);
          });
          item.append(editButton, meta, removeButton);
          customListEl.appendChild(item);
        });
      };

      const renderSampleList = () => {
        sampleListEl.innerHTML = '';
        SAMPLE_NODE_TEMPLATES.forEach((sample) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'designer-sample';
          button.innerHTML = `<strong>${sample.label}</strong><span>${sample.description}</span>`;
          button.addEventListener('click', () =>
            loadSpecIntoForm(
              {
                ...sample,
                id: '',
                label: sample.label.replace(/^Sample:\s*/i, ''),
                category: 'Custom',
                inputs: [...(sample.inputs || [])],
                outputs: [...(sample.outputs || [])],
                constants: (sample.constants || []).map((constant) => ({ ...constant })),
                script: sample.script,
              },
              { fromSample: true }
            )
          );
          sampleListEl.appendChild(button);
        });
      };

      const ensureDesignerInitialized = () => {
        if (designerInitialized) return;
        renderSampleList();
        if (customSpecs.length) {
          loadSpecIntoForm(customSpecs[0]);
        } else {
          loadSpecIntoForm(createEmptySpec());
        }
        designerInitialized = true;
      };

      const openDesigner = () => {
        ensureDesignerInitialized();
        designerEl.classList.add('open');
        designerEl.setAttribute('aria-hidden', 'false');
        document.body.classList.add('designer-open');
        renderCustomNodeList();
        setTimeout(() => fields.label.focus(), 50);
        setTimeout(() => editor?.resize(), 260);
      };

      const openDesignerForSpec = (specId, fallbackSpec) => {
        ensureDesignerInitialized();
        const findSpec = () => customSpecs.find((item) => item.id === specId);
        let spec = findSpec();

        if (!spec && fallbackSpec && fallbackSpec.id === specId) {
          spec = cloneSpec(fallbackSpec);
        }

        if (!spec) {
          refreshLibrary({ persist: false });
          spec = findSpec();
        }

        if (spec) {
          loadSpecIntoForm(spec);
          designerStatus.textContent = `編集中: ${spec.id}`;
        } else {
          loadSpecIntoForm(createEmptySpec());
          designerStatus.textContent = '指定されたカスタムノードが見つかりません。';
        }
        openDesigner();
      };

      const closeDesigner = () => {
        designerEl.classList.remove('open');
        designerEl.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('designer-open');
        setTimeout(() => editor?.resize(), 260);
      };

      editor = new NodeEditor({
        paletteEl,
        nodeLayer,
        connectionLayer,
        propertyDialog,
        propertyForm,
        propertyFields,
        nodeTemplate,
        library: specsToDefinitions(customSpecs),
        onGenerateScript: exportScript,
        onEditCustomNode: openDesignerForSpec,
        onDuplicatePaletteNode: ({ definitionId }) => {
          const saved = duplicateCustomNodeById(definitionId);
          if (!saved) {
            return null;
          }
          const [definition] = specsToDefinitions([saved]);
          return { id: saved.id, definition };
        },
        onRemovePaletteNode: ({
          definitionId,
          definitionIds,
          skipConfirm,
          silent,
        }) => {
          if (Array.isArray(definitionIds) && definitionIds.length) {
            const result = deleteCustomNodesByIds(definitionIds, {
              skipConfirm,
              silent,
            });
            if (result.cancelled) {
              return false;
            }
            return { removedIds: result.removedIds };
          }
          return deleteCustomNodeById(definitionId, {
            skipConfirm,
            silent,
          });
        },
        persistence: {
          load: loadGraph,
          save: saveGraph,
          clear: clearGraph,
        },
      });

      window.addEventListener('resize', () => editor.resize());

      document.getElementById('export-script').addEventListener('click', () => editor.exportScript());
      runButton?.addEventListener('click', async () => {
        if (!editor) {
          return;
        }
        let builtScript = '';
        try {
          builtScript = editor.generateScript();
        } catch (error) {
          alert(error.message);
          return;
        }
        if (!builtScript.trim()) {
          alert('生成されたスクリプトが空です。');
          return;
        }

        runButton.disabled = true;
        try {
          const response = await executeWithPowerShell(builtScript);
          if (!response || !response.command) {
            alert('PowerShell ブリッジから正しい応答を受信できませんでした。');
            return;
          }
          appendLogEntry(response.command, { prepend: true });
          if (activeSession) {
            updateSessionUI(activeSession, { statusMessage: response.ok ? 'Ready' : 'Command failed' });
          }
          if (response.ok) {
            showToast('PowerShell スクリプトを実行しました。');
          } else {
            const errors = collectMessages(response.command?.result?.streams?.error, (item) => item?.message ?? item);
            alert(`PowerShell 実行時にエラーが発生しました。\n${errors.join('\n') || '詳細は Execution Console を確認してください。'}`);
          }
        } catch (error) {
          alert(`PowerShell API 呼び出し中に例外が発生しました:\n${error.message}`);
        } finally {
          runButton.disabled = false;
        }
      });
      document.getElementById('save-flow').addEventListener('click', () => editor.persistGraph());
      document.getElementById('load-flow').addEventListener('click', () => editor.restoreGraph());
      document.getElementById('clear-flow').addEventListener('click', () => editor.clearGraph());

      newSessionBtn?.addEventListener('click', async () => {
        newSessionBtn.disabled = true;
        try {
          await closeCurrentSession({ silent: true });
          await ensureSession();
          await loadHistory();
          showToast('新しいセッションを確立しました。');
        } catch (error) {
          alert(`新しいセッションの作成に失敗しました:\n${error.message}`);
        } finally {
          newSessionBtn.disabled = false;
        }
      });

      refreshHistoryBtn?.addEventListener('click', async () => {
        refreshHistoryBtn.disabled = true;
        try {
          await loadHistory();
          showToast('履歴を更新しました。');
        } catch (error) {
          alert(`履歴の取得に失敗しました:\n${error.message}`);
        } finally {
          refreshHistoryBtn.disabled = false;
        }
      });

      apiInput?.addEventListener('change', async () => {
        const endpoint = getApiRoot();
        if (apiInput) {
          apiInput.value = endpoint;
        }
        try {
          await closeCurrentSession({ silent: true });
          await ensureSession();
          await loadHistory();
          showToast(`接続先を ${endpoint} に切り替えました。`);
        } catch (error) {
          alert(`API エンドポイントへの接続に失敗しました:\n${error.message}`);
        }
      });

      window.addEventListener('beforeunload', () => {
        if (!activeSession) {
          return;
        }
        const endpoint = getApiRoot();
        fetch(`${endpoint}/sessions/${activeSession.id}`, {
          method: 'DELETE',
          keepalive: true,
        }).catch(() => {});
      });

      loadHistory().catch((error) => {
        console.warn('Failed to initialize PowerShell session', error);
      });

      openDesignerBtn.addEventListener('click', openDesigner);
      closeDesignerBtn.addEventListener('click', closeDesigner);
      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && designerEl.classList.contains('open')) {
          closeDesigner();
        }
      });

      newNodeBtn.addEventListener('click', () => {
        loadSpecIntoForm(createEmptySpec());
        designerStatus.textContent = '新しいノードを作成しています。';
      });

      duplicateNodeBtn.addEventListener('click', () => {
        const label = fields.label.value.trim();
        const spec = {
          id: sanitizeToken(fields.id.value.trim()) || originalId || sanitizeToken(label).toLowerCase(),
          label: label || 'Untitled node',
          category: fields.category.value.trim() || 'Custom',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
        };
        const saved = duplicateSpecWithNewId(spec);
        if (!saved) {
          return;
        }
        showToast('カスタムノードを複製しました。');
        refreshLibrary();
        loadSpecIntoForm(saved);
      });

      resetFormBtn.addEventListener('click', () => {
        loadSpecIntoForm(createEmptySpec());
        designerStatus.textContent = '入力をリセットしました。';
      });

      scriptField.addEventListener('keydown', (event) => {
        if (event.key === 'Tab') {
          event.preventDefault();
          const { selectionStart, selectionEnd, value } = scriptField;
          const insertion = '  ';
          scriptField.value = `${value.slice(0, selectionStart)}${insertion}${value.slice(selectionEnd)}`;
          const caret = selectionStart + insertion.length;
          scriptField.selectionStart = caret;
          scriptField.selectionEnd = caret;
        }
      });

      designerForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const label = fields.label.value.trim();
        let id = sanitizeToken(fields.id.value.trim());
        if (!id) {
          id = originalId || sanitizeToken(label).toLowerCase();
        }
        if (!id) {
          id = `custom_node_${Date.now()}`;
        }
        const spec = {
          id,
          label: label || 'Untitled node',
          category: fields.category.value.trim() || 'Custom',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
        };
        const existing = customSpecs.find((item) => item.id === spec.id);
        if (existing && existing.id !== originalId) {
          const overwrite = confirm('このIDのノードは既に存在します。上書きしますか？');
          if (!overwrite) {
            return;
          }
        }
        const saved = saveCustomNodeSpec(spec);
        showToast('カスタムノードを保存しました (ローカルストレージ)。');
        refreshLibrary();
        loadSpecIntoForm(saved);
      });

      renderCustomNodeList();

    </script>
  </body>
</html>
