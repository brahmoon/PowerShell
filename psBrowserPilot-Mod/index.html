<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PowerShell Visual Builder</title>
    <link rel="stylesheet" href="./ui/editor.css" />
  </head>
  <body>
    <header class="app-header">
      <div class="branding">
        <div class="logo" aria-hidden="true"></div>
        <h1>PowerShell Visual Builder</h1>
      </div>
      <div class="header-actions">
        <button id="open-designer" type="button">Custom Nodes</button>
        <button id="load-flow" type="button">Load</button>
        <button id="save-flow" type="button">Save</button>
        <button id="clear-flow" type="button">Clear</button>
        <button id="export-script" class="secondary" type="button">Export Script</button>
        <button id="run-script" class="primary" type="button">Run in PowerShell</button>
      </div>
    </header>

    <div class="app-body">
      <aside class="palette-shell" aria-label="Node palette">
        <div class="palette" id="node-palette"></div>
        <div class="palette-status-bar">
          <button
            type="button"
            id="open-settings"
            class="status-icon"
            aria-haspopup="dialog"
            aria-controls="settings-dialog"
            aria-label="設定を開く"
            aria-expanded="false"
          >⚙</button>
        </div>
      </aside>
      <main class="editor" id="editor-area">
        <canvas id="connection-layer"></canvas>
        <div id="node-layer" class="node-layer" role="application" aria-label="Node editor"></div>
      </main>
    </div>

    <dialog id="settings-dialog" class="settings-dialog" aria-label="設定">
      <div class="settings-inner">
        <header class="settings-header">
          <h2>設定</h2>
          <button type="button" id="close-settings" class="settings-close" aria-label="設定を閉じる">
            ×
          </button>
        </header>
        <div class="settings-content">
          <div class="settings-group">
            <span id="theme-toggle-label" class="toggle-field-label">テーマ</span>
            <label class="toggle-switch" for="theme-toggle">
              <span class="toggle-text" id="theme-toggle-text">ダークモード</span>
              <input
                type="checkbox"
                id="theme-toggle"
                aria-labelledby="theme-toggle-label theme-toggle-text"
              />
              <span class="toggle-slider" aria-hidden="true"></span>
            </label>
          </div>
          <div class="settings-group stacked">
            <label for="server-url">PowerShell サーバーURL</label>
            <input
              id="server-url"
              type="text"
              inputmode="url"
              placeholder="http://127.0.0.1:8787"
            />
            <p class="settings-hint">
              <code>/runScript</code> エンドポイントを公開しているサーバーを指定してください。付属の
              <code>psBrowserPilotLocal.ps1</code> は <code>http://127.0.0.1:8787</code> で待ち受けます。
            </p>
            <div class="settings-inline-actions">
              <button type="button" id="test-server" class="small-button">接続テスト</button>
              <span id="server-status" class="settings-note">未テスト</span>
            </div>
          </div>
        </div>
      </div>
    </dialog>

    <template id="node-template">
      <div class="node" tabindex="0">
        <header class="node-header">
          <span class="node-label"></span>
          <div class="node-actions">
            <button
              class="node-open-designer"
              title="カスタムノードエディタを開く"
              type="button"
            >&lt;&gt;</button>
            <button
              class="node-delete"
              title="ノードを削除"
              type="button"
              aria-label="ノードを削除"
            >✕</button>
          </div>
        </header>
        <div class="node-controls"></div>
        <div class="node-ports">
          <div class="inputs"></div>
          <div class="outputs"></div>
        </div>
      </div>
    </template>

    <aside id="node-designer" class="designer" aria-hidden="true">
      <div class="designer-panel">
        <header class="designer-header">
          <div>
            <h2>カスタムノードビルダー</h2>
            <p class="designer-caption">
              ノードの入出力ポートとスクリプトを定義し、ブラウザのストレージに保存できます。
            </p>
          </div>
          <div class="designer-header-actions">
            <button
              type="button"
              id="open-designer-help"
              class="designer-help-button"
              aria-label="カスタムノードのヘルプを開く"
              aria-haspopup="dialog"
              aria-controls="designer-help-dialog"
            >
              ヘルプ
            </button>
            <button type="button" id="close-designer" class="designer-close" aria-label="Close designer">
              ×
            </button>
          </div>
        </header>
        <div class="designer-content">
          <section class="designer-sidebar">
            <div class="designer-section">
              <div class="designer-section-header">
                <h3>保存済みノード</h3>
                <button type="button" id="create-node" class="small-button">新規</button>
              </div>
              <div id="custom-node-list" class="designer-list" role="list"></div>
            </div>
            <div class="designer-section">
              <h3>サンプル</h3>
              <p class="designer-hint">サンプルを読み込むとフォームに内容がコピーされます。</p>
              <div id="sample-node-list" class="designer-list" role="list"></div>
            </div>
          </section>
          <section class="designer-form">
            <form id="custom-node-form" autocomplete="off">
              <div class="field-group">
                <label for="node-label">表示名</label>
                <input id="node-label" name="label" type="text" placeholder="例: ファイル読込" required />
              </div>
              <div class="field-grid">
                <label>
                  ノードID
                  <input id="node-id" name="id" type="text" placeholder="例: file_loader" />
                </label>
                <label>
                  カテゴリ
                  <input id="node-category" name="category" type="text" placeholder="Custom" />
                </label>
              </div>
              <div class="field-group">
                <label for="node-execution">ノード種別</label>
                <select id="node-execution" name="execution">
                  <option value="powershell">PowerShell 実行ノード</option>
                  <option value="ui">GUI ノード</option>
                </select>
                <p class="field-hint">GUIノードはPowerShellスクリプトに含まれず、ブラウザUI上での操作に利用されます。</p>
              </div>
              <div class="field-group">
                <label for="node-inputs">入力ポート（1行につき1件）</label>
                <textarea id="node-inputs" name="inputs" rows="3" placeholder="InputValue"></textarea>
              </div>
              <div class="field-group">
                <label for="node-outputs">出力ポート（1行につき1件）</label>
                <textarea id="node-outputs" name="outputs" rows="3" placeholder="Result"></textarea>
              </div>
              <div class="field-group">
                <label for="node-constants">定数入力（ Type | Key | Value ）</label>
                <textarea
                  id="node-constants"
                  name="constants"
                  rows="4"
                  placeholder="TextBox | threshold | # TODO: set value"
                ></textarea>
              </div>
              <div class="field-group" data-execution="powershell">
                <label for="node-script">PowerShell スクリプト</label>
                <textarea
                  id="node-script"
                  name="script"
                  class="code-area"
                  rows="12"
                  placeholder="# {{input.Value}} や {{config.threshold}} のようなプレースホルダーを使用できます。"
                ></textarea>
              </div>
              <div class="field-group" data-execution="ui">
                <label for="node-ui-markup">UI マークアップ (HTML)</label>
                <textarea
                  id="node-ui-markup"
                  name="uiMarkup"
                  rows="6"
                  placeholder="&lt;div class=&quot;custom-ui-node&quot;&gt;...&lt;/div&gt;"
                ></textarea>
                <p class="field-hint">ノードのコントロール領域に挿入されるHTMLを定義します。</p>
              </div>
              <div class="field-group" data-execution="ui">
                <label for="node-ui-script">UI スクリプト (JavaScript)</label>
                <textarea
                  id="node-ui-script"
                  name="uiScript"
                  class="code-area"
                  rows="12"
                  placeholder="// context.updateConfig(...) を使って出力値を更新します。"
                ></textarea>
                <p class="field-hint">
                  <code>context</code> には
                  <a href="#" class="designer-help-link" data-help-target="updateConfig"><code>updateConfig</code></a>・
                  <a href="#" class="designer-help-link" data-help-target="resolveInput"><code>resolveInput</code></a>・
                  <a href="#" class="designer-help-link" data-help-target="toPowerShellLiteral"><code>toPowerShellLiteral</code></a>
                  などのヘルパーが含まれます。
                </p>
              </div>
              <div class="field-group" data-execution="ui">
                <label for="node-ui-style">UI スタイル (CSS)</label>
                <textarea
                  id="node-ui-style"
                  name="uiStyle"
                  class="code-area"
                  rows="10"
                  placeholder="/* ノード専用のスタイルを記述します */"
                ></textarea>
              </div>
              <p id="designer-status" class="designer-status" role="status" aria-live="polite"></p>
              <div class="designer-actions">
                <button type="submit" class="primary">保存</button>
                <button type="button" id="duplicate-node">複製</button>
                <button type="button" id="reset-form">リセット</button>
              </div>
            </form>
          </section>
        </div>
      </div>
    </aside>

    <dialog id="designer-help-dialog" class="designer-help-dialog" aria-label="カスタムノードヘルプ">
      <div class="designer-help-inner">
        <header class="designer-help-header">
          <div>
            <h2>カスタムノードヘルプ</h2>
            <p class="designer-help-caption">
              カスタムGUIノードのスクリプトから利用できる <code>context</code> ヘルパーの使い方をまとめています。
            </p>
          </div>
          <button type="button" id="close-designer-help" class="designer-help-close" aria-label="ヘルプを閉じる">
            ×
          </button>
        </header>
        <div class="designer-help-content">
          <p>
            GUIノードの <code>render</code> スクリプトには <code>context</code> オブジェクトが渡され、ノードの状態や入出力を安全に制御できます。
            以下のヘルパーは組み合わせて利用するケースが多いので、必要に応じてセクションを参照してください。
          </p>
          <section class="designer-help-section" id="designer-help-updateConfig" data-help-section="updateConfig">
            <h3><code>updateConfig(name, value, options?)</code></h3>
            <p>ノードの構成値および出力値を更新します。引数は以下の通りです。</p>
            <ul>
              <li><strong><code>name</code></strong>: 更新したいキー名。出力の場合は <code>Result</code>、生値は <code>Result__raw</code> のように指定します。</li>
              <li><strong><code>value</code></strong>: 設定する値。PowerShellへ渡す場合は <code>toPowerShellLiteral</code> の結果を使います。</li>
              <li><strong><code>options.silent</code></strong> (省略可): <code>true</code> の場合はUI更新を抑制し、内部状態だけを変更します。</li>
            </ul>
            <pre><code class="language-js">const scriptValue = toPowerShellLiteral('OK');
updateConfig('Result__raw', 'OK', { silent: true });
updateConfig('Result', scriptValue);</code></pre>
          </section>
          <section class="designer-help-section" id="designer-help-resolveInput" data-help-section="resolveInput">
            <h3><code>resolveInput(name, options?)</code></h3>
            <p>
              指定した入力ポートから現在の値を取得します。接続されていない場合は <code>null</code> を返します。PowerShellで扱いやすい生値を取得したい場合は
              <code>{ preferRaw: true }</code> を指定します。
            </p>
            <pre><code class="language-js">const workbook = resolveInput('WorkbookName', { preferRaw: true });
if (workbook) {
  updateConfig('WorkbookName__raw', workbook, { silent: true });
}</code></pre>
          </section>
          <section class="designer-help-section" id="designer-help-toPowerShellLiteral" data-help-section="toPowerShellLiteral">
            <h3><code>toPowerShellLiteral(value)</code></h3>
            <p>
              JavaScriptの値をPowerShellスクリプト内で安全に展開できるリテラル文字列へ変換します。文字列のクォート処理や配列・数値・ブール値の表現を自動で行います。
            </p>
            <pre><code class="language-js">const items = ['A', 'B', 'C'];
const literal = toPowerShellLiteral(items);
updateConfig('SelectedItems', literal);</code></pre>
            <p class="designer-help-note">
              リテラル化した値を <code>updateConfig</code> で出力に設定することで、生成されたPowerShellスクリプトへそのまま埋め込まれます。
            </p>
          </section>
        </div>
      </div>
    </dialog>

    <script type="module">
      import {
        listCustomNodeSpecs,
        saveCustomNodeSpec,
        deleteCustomNodeSpec,
        specsToDefinitions,
        SAMPLE_NODE_TEMPLATES,
        createEmptySpec,
      } from './core/nodeLibrary.js';
      import { BUILTIN_NODES } from './core/builtinNodes.js';
      import { NodeEditor } from './core/nodeEngine.js';
      import { loadGraph, saveGraph, clearGraph } from './storage/fileStore.js';
      import { exportScript } from './export/scriptExport.js';
      import {
        runScriptWithDialog,
        loadServerUrl,
        saveServerUrl,
        normalizeServerUrl,
        DEFAULT_SERVER_URL,
      } from './export/scriptRunner.js';

      const paletteEl = document.getElementById('node-palette');
      const nodeLayer = document.getElementById('node-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const nodeTemplate = document.getElementById('node-template');
      const exportButton = document.getElementById('export-script');
      const runButton = document.getElementById('run-script');
      const serverUrlInput = document.getElementById('server-url');
      const testServerBtn = document.getElementById('test-server');
      const serverStatus = document.getElementById('server-status');

      let customSpecs = [];
      let editor;
      let powerShellServerUrl = loadServerUrl();

      const sortSpecsByLabel = (specs) =>
        [...(specs || [])].sort((a, b) => (a.label || '').localeCompare(b.label || ''));

      const mergeCustomSpecList = (base = [], updates = []) => {
        const map = new Map();
        base.forEach((spec) => {
          if (spec?.id) {
            map.set(spec.id, spec);
          }
        });
        updates.forEach((spec) => {
          if (spec?.id) {
            map.set(spec.id, spec);
          }
        });
        return sortSpecsByLabel(Array.from(map.values()));
      };

      const updateServerStatus = (message, state = 'info') => {
        if (!serverStatus) return;
        const classes = ['settings-note'];
        if (state) {
          classes.push(`is-${state}`);
        }
        serverStatus.textContent = message;
        serverStatus.className = classes.join(' ');
      };

      const applyServerUrl = (value, { silent = false } = {}) => {
        const normalized = normalizeServerUrl(value);
        const next = normalized || DEFAULT_SERVER_URL;
        powerShellServerUrl = next;
        if (serverUrlInput) {
          serverUrlInput.value = next;
        }
        saveServerUrl(next);
        if (!silent) {
          updateServerStatus(`使用中: ${next}`, 'info');
        }
      };

      applyServerUrl(powerShellServerUrl, { silent: true });
      updateServerStatus(`使用中: ${powerShellServerUrl}`, 'info');

      const testServerConnection = async () => {
        const candidate = normalizeServerUrl(serverUrlInput?.value || powerShellServerUrl);
        const target = candidate || DEFAULT_SERVER_URL;
        applyServerUrl(target, { silent: true });
        updateServerStatus('接続テスト中…', 'pending');
        try {
          const response = await fetch(`${target.replace(/\/+$/, '')}/`, { method: 'GET' });
          const contentType = response.headers.get('content-type') || '';
          let data = null;
          if (contentType.includes('application/json')) {
            try {
              data = await response.json();
            } catch (error) {
              data = null;
            }
          }
          if (!response.ok) {
            throw new Error(data?.error || `HTTP ${response.status}`);
          }
          if (data?.message) {
            updateServerStatus(`接続に成功: ${data.message}`, 'success');
          } else {
            updateServerStatus('接続に成功しました。', 'success');
          }
        } catch (error) {
          updateServerStatus(`接続に失敗: ${error.message}`, 'error');
        }
      };

      serverUrlInput?.addEventListener('blur', async (event) => {
        applyServerUrl(event.target.value);
        try {
          await refreshLibrary({ persist: false, silent: true });
        } catch (error) {
          console.error('Failed to refresh library after server URL change', error);
        }
      });

      serverUrlInput?.addEventListener('keydown', async (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          applyServerUrl(event.currentTarget.value);
          testServerConnection();
          try {
            await refreshLibrary({ persist: false, silent: true });
          } catch (error) {
            console.error('Failed to refresh library after server URL change', error);
          }
        }
      });

      testServerBtn?.addEventListener('click', (event) => {
        event.preventDefault();
        testServerConnection();
      });

      const showToast = (message) => {
        if (!message) return;
        const div = document.createElement('div');
        div.textContent = message;
        div.className = 'toast';
        document.body.appendChild(div);
        requestAnimationFrame(() => {
          div.classList.add('visible');
        });
        setTimeout(() => {
          div.classList.remove('visible');
          setTimeout(() => div.remove(), 240);
        }, 1800);
      };

      const cloneBuiltinDefinition = (definition) => ({
        ...definition,
        inputs: Array.isArray(definition.inputs) ? [...definition.inputs] : [],
        outputs: Array.isArray(definition.outputs) ? [...definition.outputs] : [],
        controls: Array.isArray(definition.controls)
          ? definition.controls.map((control) => ({ ...control }))
          : undefined,
        initialConfig:
          definition.initialConfig && typeof definition.initialConfig === 'object'
            ? { ...definition.initialConfig }
            : undefined,
      });

      const buildLibraryDefinitions = () => [
        ...BUILTIN_NODES.map(cloneBuiltinDefinition),
        ...specsToDefinitions(customSpecs),
      ];

      const loadCustomSpecs = async ({ silent = false } = {}) => {
        try {
          const specs = await listCustomNodeSpecs({ serverUrl: powerShellServerUrl });
          customSpecs = sortSpecsByLabel(specs);
          return customSpecs;
        } catch (error) {
          console.error('Failed to load custom nodes', error);
          if (!silent) {
            showToast('カスタムノードの取得に失敗しました。');
          }
          throw error;
        }
      };

      const refreshLibrary = async ({ persist = true, silent = false, fallbackSpecs = [] } = {}) => {
        let nextSpecs = mergeCustomSpecList(customSpecs, fallbackSpecs);
        try {
          const specs = await loadCustomSpecs({ silent });
          nextSpecs = mergeCustomSpecList(specs, fallbackSpecs);
        } catch (error) {
          // Keep existing specs on failure.
          nextSpecs = mergeCustomSpecList(customSpecs, fallbackSpecs);
        }
        customSpecs = nextSpecs;
        if (editor) {
          editor.setLibrary(buildLibraryDefinitions(), { persist });
        }
        renderCustomNodeList();
      };

      const designerEl = document.getElementById('node-designer');
      const openDesignerBtn = document.getElementById('open-designer');
      const closeDesignerBtn = document.getElementById('close-designer');
      const newNodeBtn = document.getElementById('create-node');
      const customListEl = document.getElementById('custom-node-list');
      const sampleListEl = document.getElementById('sample-node-list');
      const designerForm = document.getElementById('custom-node-form');
      const resetFormBtn = document.getElementById('reset-form');
      const duplicateNodeBtn = document.getElementById('duplicate-node');
      const designerStatus = document.getElementById('designer-status');
      const scriptField = document.getElementById('node-script');
      const uiMarkupField = document.getElementById('node-ui-markup');
      const uiScriptField = document.getElementById('node-ui-script');
      const uiStyleField = document.getElementById('node-ui-style');
      const openSettingsBtn = document.getElementById('open-settings');
      const settingsDialog = document.getElementById('settings-dialog');
      const closeSettingsBtn = document.getElementById('close-settings');
      const themeToggle = document.getElementById('theme-toggle');
      const openDesignerHelpBtn = document.getElementById('open-designer-help');
      const designerHelpDialog = document.getElementById('designer-help-dialog');
      const closeDesignerHelpBtn = document.getElementById('close-designer-help');

      const THEME_STORAGE_KEY = 'nodeflow.theme';
      const CONSTANT_PLACEHOLDER = '# TODO: set value';
      const DEFAULT_UI_SPEC = createEmptySpec('ui').ui;

      const fields = {
        id: document.getElementById('node-id'),
        label: document.getElementById('node-label'),
        category: document.getElementById('node-category'),
        execution: document.getElementById('node-execution'),
        inputs: document.getElementById('node-inputs'),
        outputs: document.getElementById('node-outputs'),
        constants: document.getElementById('node-constants'),
        script: scriptField,
        uiMarkup: uiMarkupField,
        uiScript: uiScriptField,
        uiStyle: uiStyleField,
      };

      fields.execution?.addEventListener('change', () => {
        const mode = fields.execution.value === 'ui' ? 'ui' : 'powershell';
        updateDesignerFieldVisibility();
        if (mode === 'ui') {
          const hasUiContent =
            fields.uiMarkup.value.trim() ||
            fields.uiScript.value.trim() ||
            fields.uiStyle.value.trim();
          if (!hasUiContent) {
            fields.uiMarkup.value = DEFAULT_UI_SPEC.markup || '';
            fields.uiScript.value = DEFAULT_UI_SPEC.script || '';
            fields.uiStyle.value = DEFAULT_UI_SPEC.style || '';
          }
        } else if (!fields.script.value.trim()) {
          fields.script.value = createEmptySpec('powershell').script;
        }
      });

      let originalId = '';
      let designerInitialized = false;

      const updateDesignerFieldVisibility = () => {
        const mode = fields.execution.value === 'ui' ? 'ui' : 'powershell';
        designerForm
          ?.querySelectorAll('[data-execution]')
          .forEach((section) => {
            const target = section.dataset.execution;
            section.hidden = !(target === mode || target === 'both' || target === 'shared');
          });
      };

      updateDesignerFieldVisibility();

      const applyTheme = (theme) => {
        const mode = theme === 'dark' ? 'dark' : 'light';
        document.body.classList.toggle('theme-dark', mode === 'dark');
        document.body.classList.toggle('theme-light', mode === 'light');
        document.documentElement.style.setProperty('color-scheme', mode);
        if (themeToggle) {
          themeToggle.checked = mode === 'dark';
        }
      };

      const detectPreferredTheme = () =>
        window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

      const loadStoredTheme = () => {
        try {
          const stored = localStorage.getItem(THEME_STORAGE_KEY);
          return stored === 'dark' || stored === 'light' ? stored : null;
        } catch (error) {
          console.warn('Failed to read theme preference', error);
          return null;
        }
      };

      const persistTheme = (theme) => {
        try {
          localStorage.setItem(THEME_STORAGE_KEY, theme);
        } catch (error) {
          console.warn('Failed to store theme preference', error);
        }
      };

      const initializeTheme = () => {
        const stored = loadStoredTheme();
        const initial = stored || detectPreferredTheme();
        applyTheme(initial);
      };

      initializeTheme();

      themeToggle?.addEventListener('change', () => {
        const mode = themeToggle.checked ? 'dark' : 'light';
        applyTheme(mode);
        persistTheme(mode);
      });

      const openSettings = () => {
        if (!settingsDialog) return;
        if (typeof settingsDialog.showModal === 'function' && !settingsDialog.open) {
          settingsDialog.showModal();
          openSettingsBtn?.setAttribute('aria-expanded', 'true');
        }
      };

      const closeSettings = ({ returnFocus = false } = {}) => {
        if (!settingsDialog) return;
        if (settingsDialog.open) {
          settingsDialog.close();
        }
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
        if (returnFocus) {
          openSettingsBtn?.focus();
        }
      };

      openSettingsBtn?.addEventListener('click', () => {
        openSettings();
      });

      closeSettingsBtn?.addEventListener('click', () => {
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('cancel', (event) => {
        event.preventDefault();
        closeSettings({ returnFocus: true });
      });

      settingsDialog?.addEventListener('close', () => {
        openSettingsBtn?.setAttribute('aria-expanded', 'false');
      });

      const setHelpExpanded = (expanded) => {
        if (openDesignerHelpBtn) {
          openDesignerHelpBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }
      };

      setHelpExpanded(false);

      const highlightHelpSection = (section) => {
        if (!section) {
          return;
        }
        const previousTabIndex = section.getAttribute('tabindex');
        section.setAttribute('tabindex', '-1');
        section.focus({ preventScroll: true });
        section.scrollIntoView({ block: 'start', behavior: 'smooth' });
        section.classList.add('is-highlighted');
        setTimeout(() => {
          section.classList.remove('is-highlighted');
          if (previousTabIndex !== null) {
            section.setAttribute('tabindex', previousTabIndex);
          } else {
            section.removeAttribute('tabindex');
          }
        }, 1600);
      };

      const openDesignerHelp = (sectionId) => {
        if (!designerHelpDialog) {
          return;
        }
        if (typeof designerHelpDialog.showModal === 'function') {
          if (!designerHelpDialog.open) {
            designerHelpDialog.showModal();
          }
        } else {
          designerHelpDialog.setAttribute('open', 'true');
        }
        setHelpExpanded(true);
        if (sectionId) {
          window.requestAnimationFrame(() => {
            const target = designerHelpDialog.querySelector(
              `[data-help-section="${sectionId}"]`
            );
            if (target) {
              highlightHelpSection(target);
            }
          });
        }
      };

      const closeDesignerHelp = ({ returnFocus = false } = {}) => {
        if (!designerHelpDialog) {
          return;
        }
        if (designerHelpDialog.open) {
          designerHelpDialog.close();
        } else {
          designerHelpDialog.removeAttribute('open');
        }
        setHelpExpanded(false);
        if (returnFocus) {
          openDesignerHelpBtn?.focus();
        }
      };

      openDesignerHelpBtn?.addEventListener('click', () => {
        openDesignerHelp();
      });

      closeDesignerHelpBtn?.addEventListener('click', () => {
        closeDesignerHelp({ returnFocus: true });
      });

      designerHelpDialog?.addEventListener('cancel', (event) => {
        event.preventDefault();
        closeDesignerHelp({ returnFocus: true });
      });

      designerHelpDialog?.addEventListener('close', () => {
        setHelpExpanded(false);
      });

      designerHelpDialog?.addEventListener('click', (event) => {
        if (event.target === designerHelpDialog) {
          closeDesignerHelp({ returnFocus: true });
        }
      });

      document.querySelectorAll('.designer-help-link[data-help-target]').forEach((link) => {
        link.addEventListener('click', (event) => {
          event.preventDefault();
          const targetId = event.currentTarget.getAttribute('data-help-target');
          openDesignerHelp(targetId);
        });
      });

      const sanitizeToken = (value) =>
        String(value ?? '')
          .trim()
          .replace(/\s+/g, '_')
          .replace(/[^A-Za-z0-9_]/g, '_');

      const parsePortList = (raw) =>
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => sanitizeToken(line))
          .filter((line, index, self) => line && self.indexOf(line) === index);

      const normalizeConstantType = (value) => {
        const normalized = String(value ?? '').trim().toLowerCase();
        switch (normalized) {
          case 'checkbox':
          case 'check-box':
            return 'CheckBox';
          case 'reference':
          case 'file':
            return 'Reference';
          case 'radiobutton':
          case 'radio':
            return 'RadioButton';
          case 'select':
          case 'selectbox':
          case 'select-box':
            return 'SelectBox';
          case 'text':
          case 'text-box':
          case 'textbox':
          default:
            return 'TextBox';
        }
      };

      const normalizeBooleanToken = (value) =>
        /^(true|1|yes|on)$/i.test(String(value ?? '').trim()) ? 'True' : 'False';

      const parseConstants = (raw) => {
        const byKey = new Map();
        String(raw ?? '')
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean)
          .forEach((line) => {
            const parts = line.split('|').map((part) => part.trim());
            if (!parts.length) return;
            let typeToken = 'TextBox';
            let keyToken = parts[0];
            let valueToken = CONSTANT_PLACEHOLDER;
            if (parts.length >= 3) {
              typeToken = parts[0];
              keyToken = parts[1];
              valueToken = parts.slice(2).join('|');
            } else if (parts.length === 2) {
              keyToken = parts[0];
              valueToken = parts[1];
            }
            const key = sanitizeToken(keyToken);
            if (!key) return;
            const type = normalizeConstantType(typeToken);
            const rawValue = valueToken ?? CONSTANT_PLACEHOLDER;
            if (type === 'SelectBox') {
              const optionValue = String(rawValue ?? '').trim();
              if (!optionValue) {
                return;
              }
              const existing = byKey.get(key);
              if (existing) {
                if (existing.type !== 'SelectBox') {
                  return;
                }
                if (!existing.options.includes(optionValue)) {
                  existing.options.push(optionValue);
                }
                if (!existing.value) {
                  existing.value = optionValue;
                }
              } else {
                byKey.set(key, {
                  key,
                  type,
                  value: optionValue,
                  options: [optionValue],
                });
              }
              return;
            }
            if (type === 'CheckBox' || type === 'RadioButton') {
              byKey.set(key, {
                key,
                type,
                value: normalizeBooleanToken(rawValue),
              });
              return;
            }
            byKey.set(key, {
              key,
              type,
              value: rawValue || CONSTANT_PLACEHOLDER,
            });
          });
        return Array.from(byKey.values()).map((constant) => {
          if (constant.type === 'SelectBox') {
            const options = Array.isArray(constant.options) ? constant.options : [];
            const unique = options.filter(
              (option, index, self) => option && self.indexOf(option) === index
            );
            const preferred = unique.includes(constant.value) ? constant.value : unique[0] || '';
            return {
              key: constant.key,
              type: constant.type,
              value: preferred,
              options: unique,
            };
          }
          return constant;
        });
      };

      const formatConstants = (constants) =>
        (constants || [])
          .reduce((lines, constant) => {
            const type = normalizeConstantType(constant?.type || 'TextBox');
            const key = sanitizeToken(constant?.key ?? '');
            if (!key) return lines;
            if (type === 'SelectBox') {
              const values = Array.from(
                new Set(
                  [
                    ...(Array.isArray(constant?.options) ? constant.options : []),
                    constant?.value,
                  ].map((option) => String(option ?? '').trim())
                )
              ).filter(Boolean);
              values.forEach((option) => {
                lines.push(`${type} | ${key} | ${option}`);
              });
              return lines;
            }
            const value =
              type === 'CheckBox' || type === 'RadioButton'
                ? normalizeBooleanToken(constant?.value ?? constant?.default)
                : constant?.value ?? constant?.default ?? CONSTANT_PLACEHOLDER;
            lines.push(`${type} | ${key} | ${value}`.trim());
            return lines;
          }, [])
          .join('\n');

      const cloneUiSpec = (ui) => ({
        markup: typeof ui?.markup === 'string' ? ui.markup : '',
        script: typeof ui?.script === 'string' ? ui.script : '',
        style: typeof ui?.style === 'string' ? ui.style : '',
      });

      const readUiSpecFromFields = () => ({
        markup: fields.uiMarkup.value.replace(/\r\n/g, '\n'),
        script: fields.uiScript.value.replace(/\r\n/g, '\n'),
        style: fields.uiStyle.value.replace(/\r\n/g, '\n'),
      });

      const cloneConstants = (constants) =>
        (constants || []).map((constant) =>
          constant
            ? {
                ...constant,
                options: Array.isArray(constant.options)
                  ? [...constant.options]
                  : constant.options,
              }
            : constant
        );

      const cloneSpec = (spec) => {
        if (!spec) return null;
        return {
          ...spec,
          execution: spec?.execution === 'ui' ? 'ui' : 'powershell',
          inputs: [...(spec.inputs || [])],
          outputs: [...(spec.outputs || [])],
          constants: cloneConstants(spec.constants || []),
          script: spec.script || '',
          ui: cloneUiSpec(spec.ui || DEFAULT_UI_SPEC),
        };
      };

      const findSpecById = (id) => customSpecs.find((spec) => spec.id === id);

      const ensureDuplicatedLabel = (label) => {
        const base = label && label.trim() ? label.trim() : 'Untitled node';
        return base.endsWith(' (複製)') ? base : `${base} (複製)`;
      };

      const generateUniqueNodeId = (seedId) => {
        const existingIds = new Set(customSpecs.map((spec) => spec.id));
        let base = sanitizeToken(seedId || '');
        if (!base) {
          base = 'custom_node';
        }
        if (!existingIds.has(base)) {
          return base;
        }
        const match = base.match(/^(.*?)(\d+)?$/);
        let prefix = match && match[1] !== undefined ? match[1] : base;
        if (!prefix) {
          prefix = base || 'custom_node';
        }
        let suffix = match && match[2] ? parseInt(match[2], 10) + 1 : 2;
        if (!Number.isFinite(suffix) || suffix < 1) {
          suffix = 2;
        }
        let candidate = `${prefix}${suffix}`;
        while (existingIds.has(candidate)) {
          suffix += 1;
          candidate = `${prefix}${suffix}`;
        }
        return candidate;
      };

      const duplicateSpecWithNewId = async (spec) => {
        if (!spec) return null;
        const working = cloneSpec(spec);
        working.execution = working.execution === 'ui' ? 'ui' : 'powershell';
        const preferredBaseId = working.id || sanitizeToken(working.label).toLowerCase();
        working.id = generateUniqueNodeId(preferredBaseId);
        working.label = ensureDuplicatedLabel(working.label);
        working.category = working.category || 'Custom';
        working.script = working.script || '';
        return saveCustomNodeSpec(working, {
          serverUrl: powerShellServerUrl,
        });
      };

      const duplicateCustomNodeById = async (specId) => {
        const spec = findSpecById(specId);
        if (!spec) {
          return null;
        }
        const saved = await duplicateSpecWithNewId(spec);
        if (saved) {
          showToast('ノードを複製しました。');
          await refreshLibrary({ fallbackSpecs: [saved] });
        }
        return saved;
      };

      const removeCustomNodeSpecs = async (ids, { skipConfirm = false, silent = false } = {}) => {
        const uniqueIds = Array.isArray(ids)
          ? Array.from(new Set(ids.filter(Boolean)))
          : [];
        if (!uniqueIds.length) {
          return { removedIds: [], cancelled: false };
        }
        const specs = uniqueIds.map((id) => findSpecById(id)).filter(Boolean);
        if (!specs.length) {
          return { removedIds: [], cancelled: false };
        }
        if (!skipConfirm) {
          const message =
            specs.length === 1
              ? `${specs[0].label} を削除しますか？`
              : `${specs.length} 件のカスタムノードを削除しますか？`;
          if (!confirm(message)) {
            return { removedIds: [], cancelled: true };
          }
        }

        for (const spec of specs) {
          await deleteCustomNodeSpec(spec.id, { serverUrl: powerShellServerUrl });
        }

        await refreshLibrary({ silent: true });

        if (specs.some((spec) => spec.id === originalId)) {
          if (customSpecs.length) {
            loadSpecIntoForm(customSpecs[0]);
          } else {
            loadSpecIntoForm(createEmptySpec());
          }
        }

        if (!silent) {
          showToast(
            specs.length === 1
              ? 'カスタムノードを削除しました。'
              : `${specs.length}件のカスタムノードを削除しました。`
          );
        }

        return {
          removedIds: specs.map((spec) => spec.id),
          cancelled: false,
        };
      };

      const deleteCustomNodeById = async (specId, options = {}) => {
        const result = await removeCustomNodeSpecs([specId], options);
        if (result.cancelled) {
          return false;
        }
        return result;
      };

      const deleteCustomNodesByIds = (ids, options = {}) => removeCustomNodeSpecs(ids, options);

      const loadSpecIntoForm = (spec, { fromSample = false } = {}) => {
        originalId = fromSample ? '' : spec.id || '';
        fields.label.value = spec.label || '';
        fields.id.value = fromSample ? '' : spec.id || '';
        fields.category.value = fromSample ? 'Custom' : spec.category || 'Custom';
        fields.execution.value = spec.execution === 'ui' ? 'ui' : 'powershell';
        fields.inputs.value = (spec.inputs || []).join('\n');
        fields.outputs.value = (spec.outputs || []).join('\n');
        fields.constants.value = formatConstants(spec.constants || []);
        fields.script.value = spec.script || '';
        const uiSpec = cloneUiSpec(spec.ui || DEFAULT_UI_SPEC);
        fields.uiMarkup.value = uiSpec.markup || '';
        fields.uiScript.value = uiSpec.script || '';
        fields.uiStyle.value = uiSpec.style || '';
        updateDesignerFieldVisibility();
        designerStatus.textContent = fromSample
          ? 'サンプルノードを読み込みました。編集して保存するとカスタムノードとして登録されます。'
          : spec.id
          ? `編集中: ${spec.id}`
          : '新しいノードを作成しています。';
      };

      const renderCustomNodeList = () => {
        customListEl.innerHTML = '';
        if (!customSpecs.length) {
          const empty = document.createElement('p');
          empty.className = 'designer-empty';
          empty.textContent = 'まだカスタムノードがありません。';
          customListEl.appendChild(empty);
          return;
        }
        customSpecs.forEach((spec) => {
          const item = document.createElement('div');
          item.className = 'designer-list-item';
          const editButton = document.createElement('button');
          editButton.type = 'button';
          editButton.className = 'designer-link';
          editButton.textContent = spec.label;
          editButton.addEventListener('click', () => loadSpecIntoForm(spec));
          const meta = document.createElement('span');
          meta.className = 'designer-meta';
          meta.textContent = spec.category || 'Custom';
          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'designer-remove';
          removeButton.textContent = '削除';
          removeButton.addEventListener('click', async (event) => {
            event.stopPropagation();
            await deleteCustomNodeById(spec.id);
          });
          item.append(editButton, meta, removeButton);
          customListEl.appendChild(item);
        });
      };

      const renderSampleList = () => {
        sampleListEl.innerHTML = '';
        SAMPLE_NODE_TEMPLATES.forEach((sample) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'designer-sample';
          button.innerHTML = `<strong>${sample.label}</strong><span>${sample.description}</span>`;
          button.addEventListener('click', () =>
            loadSpecIntoForm(
              {
                ...sample,
                id: '',
                label: sample.label.replace(/^Sample:\s*/i, ''),
                category: 'Custom',
                execution: sample.execution === 'ui' ? 'ui' : 'powershell',
                inputs: [...(sample.inputs || [])],
                outputs: [...(sample.outputs || [])],
                constants: cloneConstants(sample.constants || []),
                script: sample.script,
                ui: cloneUiSpec(sample.ui || DEFAULT_UI_SPEC),
              },
              { fromSample: true }
            )
          );
          sampleListEl.appendChild(button);
        });
      };

      const ensureDesignerInitialized = () => {
        if (designerInitialized) return;
        renderSampleList();
        if (customSpecs.length) {
          loadSpecIntoForm(customSpecs[0]);
        } else {
          loadSpecIntoForm(createEmptySpec());
        }
        designerInitialized = true;
      };

      const openDesigner = () => {
        ensureDesignerInitialized();
        designerEl.classList.add('open');
        designerEl.setAttribute('aria-hidden', 'false');
        document.body.classList.add('designer-open');
        renderCustomNodeList();
        setTimeout(() => fields.label.focus(), 50);
        setTimeout(() => editor?.resize(), 260);
      };

      const openDesignerForSpec = async (specId, fallbackSpec) => {
        ensureDesignerInitialized();
        const findSpec = () => customSpecs.find((item) => item.id === specId);
        let spec = findSpec();

        if (!spec && fallbackSpec && fallbackSpec.id === specId) {
          spec = cloneSpec(fallbackSpec);
        }

        if (!spec) {
          const fallbacks = fallbackSpec && fallbackSpec.id ? [fallbackSpec] : [];
          await refreshLibrary({ persist: false, silent: true, fallbackSpecs: fallbacks });
          spec = findSpec();
        }

        if (spec) {
          loadSpecIntoForm(spec);
          designerStatus.textContent = `編集中: ${spec.id}`;
        } else {
          loadSpecIntoForm(createEmptySpec());
          designerStatus.textContent = '指定されたカスタムノードが見つかりません。';
        }
        openDesigner();
      };

      const closeDesigner = () => {
        closeDesignerHelp({ returnFocus: false });
        designerEl.classList.remove('open');
        designerEl.setAttribute('aria-hidden', 'true');
        document.body.classList.remove('designer-open');
        setTimeout(() => editor?.resize(), 260);
      };

      try {
        await loadCustomSpecs({ silent: true });
      } catch (error) {
        console.error('Failed to load custom nodes during initialization', error);
      }
      renderCustomNodeList();

      editor = new NodeEditor({
        paletteEl,
        nodeLayer,
        connectionLayer,
        nodeTemplate,
        library: buildLibraryDefinitions(),
        onGenerateScript: exportScript,
        onRunScript: (script) =>
          runScriptWithDialog(script, { serverUrl: powerShellServerUrl }),
        onEditCustomNode: openDesignerForSpec,
        onDuplicatePaletteNode: async ({ definitionId }) => {
          const saved = await duplicateCustomNodeById(definitionId);
          if (!saved) {
            return null;
          }
          const [definition] = specsToDefinitions([saved]);
          return { id: saved.id, definition };
        },
        onRemovePaletteNode: async ({
          definitionId,
          definitionIds,
          skipConfirm,
          silent,
        }) => {
          if (Array.isArray(definitionIds) && definitionIds.length) {
            const result = await deleteCustomNodesByIds(definitionIds, {
              skipConfirm,
              silent,
            });
            if (result.cancelled) {
              return false;
            }
            return { removedIds: result.removedIds };
          }
          return deleteCustomNodeById(definitionId, {
            skipConfirm,
            silent,
          });
        },
        persistence: {
          load: loadGraph,
          save: saveGraph,
          clear: clearGraph,
        },
      });

      window.addEventListener('resize', () => editor.resize());

      exportButton?.addEventListener('click', () => editor.exportScript());
      runButton?.addEventListener('click', () => editor.runScript());
      document.getElementById('save-flow').addEventListener('click', () => editor.persistGraph());
      document.getElementById('load-flow').addEventListener('click', () => editor.restoreGraph());
      document.getElementById('clear-flow').addEventListener('click', () => editor.clearGraph());

      openDesignerBtn.addEventListener('click', openDesigner);
      closeDesignerBtn.addEventListener('click', closeDesigner);
      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && designerEl.classList.contains('open')) {
          closeDesigner();
        }
      });

      newNodeBtn.addEventListener('click', () => {
        const mode = fields.execution.value === 'ui' ? 'ui' : 'powershell';
        loadSpecIntoForm(createEmptySpec(mode));
        designerStatus.textContent = '新しいノードを作成しています。';
      });

      duplicateNodeBtn.addEventListener('click', async () => {
        const label = fields.label.value.trim();
        const spec = {
          id: sanitizeToken(fields.id.value.trim()) || originalId || sanitizeToken(label).toLowerCase(),
          label: label || 'Untitled node',
          category: fields.category.value.trim() || 'Custom',
          execution: fields.execution.value === 'ui' ? 'ui' : 'powershell',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
          ui: readUiSpecFromFields(),
        };
        const saved = await duplicateSpecWithNewId(spec);
        if (!saved) {
          return;
        }
        showToast('カスタムノードを複製しました。');
        await refreshLibrary({ fallbackSpecs: [saved] });
        loadSpecIntoForm(saved);
      });

      resetFormBtn.addEventListener('click', () => {
        const mode = fields.execution.value === 'ui' ? 'ui' : 'powershell';
        loadSpecIntoForm(createEmptySpec(mode));
        designerStatus.textContent = '入力をリセットしました。';
      });

      const attachTabHandler = (textarea) => {
        if (!textarea) return;
        textarea.addEventListener('keydown', (event) => {
          if (event.key === 'Tab') {
            event.preventDefault();
            const { selectionStart, selectionEnd, value } = textarea;
            const insertion = '  ';
            textarea.value = `${value.slice(0, selectionStart)}${insertion}${value.slice(selectionEnd)}`;
            const caret = selectionStart + insertion.length;
            textarea.selectionStart = caret;
            textarea.selectionEnd = caret;
          }
        });
      };

      [scriptField, uiScriptField, uiStyleField, uiMarkupField].forEach(attachTabHandler);

      designerForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const label = fields.label.value.trim();
        let id = sanitizeToken(fields.id.value.trim());
        if (!id) {
          id = originalId || sanitizeToken(label).toLowerCase();
        }
        if (!id) {
          id = `custom_node_${Date.now()}`;
        }
        const spec = {
          id,
          label: label || 'Untitled node',
          category: fields.category.value.trim() || 'Custom',
          execution: fields.execution.value === 'ui' ? 'ui' : 'powershell',
          inputs: parsePortList(fields.inputs.value),
          outputs: parsePortList(fields.outputs.value),
          constants: parseConstants(fields.constants.value),
          script: fields.script.value.replace(/\r\n/g, '\n'),
          ui: readUiSpecFromFields(),
        };
        const existing = customSpecs.find((item) => item.id === spec.id);
        if (existing && existing.id !== originalId) {
          const overwrite = confirm('このIDのノードは既に存在します。上書きしますか？');
          if (!overwrite) {
            return;
          }
        }
        let saved;
        try {
          saved = await saveCustomNodeSpec(spec, {
            serverUrl: powerShellServerUrl,
            previous: existing,
          });
        } catch (error) {
          alert(`カスタムノードの保存に失敗しました: ${error.message}`);
          return;
        }
        showToast('カスタムノードを保存しました。');
        await refreshLibrary({ fallbackSpecs: [saved] });
        loadSpecIntoForm(saved);
      });

    </script>
  </body>
</html>
